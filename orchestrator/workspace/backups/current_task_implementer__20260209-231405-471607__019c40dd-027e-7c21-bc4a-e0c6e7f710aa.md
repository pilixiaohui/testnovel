# Current Task (Iteration 20)
assigned_agent: IMPLEMENTER
self_test: enabled

## 任务目标
SYNTHESIZER Iteration 19 返回 REWORK。这是第20轮迭代，以下问题必须彻底解决。

## 必须修复的具体错误

### 1. /api/v1/snowflake/steps 保存返回 400 "scene.title required"
- 这是新发现的错误，之前未出现
- 要求：调研 snowflake steps 保存端点的请求模型，找出 scene.title 字段的来源
- 检查前端保存时是否遗漏了 scene 对象的 title 字段
- 用 curl 测试确认

### 2. /api/v1/snowflake/step5b 仍返回 400
- 上轮 IMPLEMENTER curl 测试显示 step5b 返回 200，但验证器仍报 400
- 可能原因：验证器发送的 payload 与 IMPLEMENTER 自测的不同
- 要求：检查 step5b 端点对不同 payload 格式的处理，确保前端实际发送的格式也能通过

### 3. /api/v1/simulation/scene 返回 500（从之前的 422 回归为 500）
- 上轮修复了 world_state 归一化，但现在变成 500 说明有新的未捕获异常
- 要求：调研 simulation/scene 端点的完整代码路径，找出 500 的确切原因
- 添加异常捕获确保不返回 500

### 4. /api/v1/roots 仍返回 500（类型边界输入）
- 上轮 curl 测试 XSS/SQL/Unicode 都返回 422，但验证器仍报 500
- 可能原因：验证器发送的输入类型与 IMPLEMENTER 测试的不同（如数字、布尔值、null、超长字符串等）
- 要求：测试以下额外输入类型：
  a) 数字作为 name: `{"name": 12345}`
  b) null 作为 name: `{"name": null}`
  c) 布尔值: `{"name": true}`
  d) 超长字符串: 10000 字符
  e) 缺少 name 字段: `{}`
  f) 完全无效 JSON

## 工作方法（强制）
1. 启动后端服务
2. 对每个失败端点用 curl 发送验证器可能发送的各种 payload
3. 找到返回 400/500 的确切 payload
4. 阅读对应端点代码修复
5. 修复后再用 curl 验证
6. 在报告中附上所有 curl 命令和响应

## 验收标准
- snowflake/steps 保存不返回 400
- step5b 对前端实际 payload 不返回 400
- simulation/scene 不返回 500
- roots 对任何类型的输入不返回 500（包括数字/null/布尔/超长/缺字段）
- 后端单元测试全部通过
- 前端单元测试全部通过
- 前端 build 成功

## 约束条件
- 必须用 curl 实际验证各种边界输入
- 不要削弱校验逻辑
- 快速失败原则
- 在报告中附上完整的 curl 测试结果

## 执行环境
- 工作目录: /home/zxh/ainovel_v3
- 代码目录: /home/zxh/ainovel_v3/project/backend
- 前端目录: /home/zxh/ainovel_v3/project/frontend
- Python: /home/zxh/ainovel_v3/project/backend/.venv/bin/python
- 环境变量:
  - MEMGRAPH_HOST=localhost
  - MEMGRAPH_PORT=7687
- 测试执行配置:
  - 前端开发端口: 5185
  - 服务启动等待: 6秒
  - unit测试超时: 120秒
  - integration测试超时: 300秒
  - e2e测试超时: 600秒

