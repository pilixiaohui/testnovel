已阅读测试行为规范
iteration: 14

## 测试需求分析

工单要求测试的功能点：
1. 渲染章节后，rendered_content被持久化到Memgraph
2. GET /api/v1/chapters/{chapter_id}返回包含rendered_content字段
3. 多次渲染同一章节，rendered_content被更新
4. 未渲染的章节，rendered_content为null或空

## 测试设计

### 设计思路
使用真实 MemgraphStorage 作为集成测试存储层，通过依赖注入替换渲染网关为可控假实现，调用渲染端点验证写入；再通过 get_chapter 直接读取验证持久化更新；最后通过 GET 端点验证读取链路（当前缺失应触发红灯）。

### 创建的测试文件
- `project/backend/tests/integration/test_chapter_persistence.py` - 章节渲染持久化与读取链路测试

### 测试用例清单

| 用例名称 | 测试场景 | 对应功能点 | 测试逻辑说明 |
|---------|---------|-----------|-------------|
| test_unrendered_chapter_has_empty_rendered_content | 未渲染章节 | 功能点4 | 直接读取chapter，rendered_content应为None或空 |
| test_render_persists_rendered_content | 渲染后持久化 | 功能点1 | 调用render端点，校验Memgraph中rendered_content一致 |
| test_render_updates_content_on_second_call | 多次渲染更新 | 功能点3 | 连续渲染两次，最终内容为第二次结果 |
| test_get_chapter_returns_rendered_content | GET读取链路 | 功能点2 | GET端点返回rendered_content |

### 关键测试逻辑
- 测试数据如何准备：使用storage_test_helpers写入Root/Branch/Commit，创建Act/Chapter。
- 调用什么接口/函数：POST `/api/v1/chapters/{chapter_id}/render`，GET `/api/v1/chapters/{chapter_id}`。
- 断言什么条件：渲染后内容写入Memgraph；二次渲染覆盖；未渲染为空；GET返回rendered_content。
- 为什么这样设计能验证需求：同时覆盖写入链路和读取链路，且验证更新覆盖。

## 测试执行

- 命令: `MEMGRAPH_HOST=localhost MEMGRAPH_PORT=7687 /home/zxh/ainovel_v3/project/backend/.venv/bin/python -m pytest tests/integration/test_chapter_persistence.py -v`
- 结果: 失败
- 红灯确认: 是（GET端点缺失返回404）

### 执行详情
- 失败用例：
  - `test_get_chapter_returns_rendered_content`：GET `/api/v1/chapters/{id}` 返回404（端点未实现）
- 通过用例：
  - `test_unrendered_chapter_has_empty_rendered_content`
  - `test_render_persists_rendered_content`
  - `test_render_updates_content_on_second_call`

## 验收标准

- 命令: `MEMGRAPH_HOST=localhost MEMGRAPH_PORT=7687 /home/zxh/ainovel_v3/project/backend/.venv/bin/python -m pytest tests/integration/test_chapter_persistence.py -v`
- 阈值: 测试文件存在、可运行，GET链路未实现应触发红灯

结论：PASS
阻塞：无

【MCP调用简报】
服务: serena
触发: 创建集成测试并执行验证
参数: create_text_file, execute_shell_command（max_answer_chars: -1）
结果: 新增测试文件1个；执行1次，红灯1处
状态: 成功