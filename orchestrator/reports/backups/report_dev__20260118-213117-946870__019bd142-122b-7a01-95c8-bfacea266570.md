已阅读开发行为规范  
iteration: 5

## 改了哪里
- `project/backend/app/storage/ports.py:177`：在 `GraphStoragePort` 增加 `build_logic_check_world_state(root_id, branch_id, scene_id) -> dict` 抽象方法（DIP）。
- `project/backend/app/storage/graph_scenes.py:590`：在 `GraphStorage`（scene 侧 mixin）实现 `build_logic_check_world_state(...)`，从图存储构建用于 logic_check 的 `world_state`（复用 `get_scene_context`），并在 root/scene 不匹配时显式失败（无兜底）。
- `project/backend/app/main.py:999`：在 `logic_check_endpoint` 中，当 locator（三件套）齐全时调用 `storage.build_logic_check_world_state(...)` 覆盖请求体 `world_state` 后再调用 `gateway.logic_check(...)`；locator 不齐全时保持原行为（含原有 400 校验逻辑不变）。

## 为什么这样改（对齐验收标准）
- 对齐“locator 存在时不得信任请求体 world_state”：`project/backend/app/main.py:999` 在调用网关前强制用存储构建结果覆盖 `payload.world_state`，测试 Stub 也通过关键字参数验证调用发生。
- 对齐“更新存储抽象（DIP）”：`project/backend/app/storage/ports.py:177` 将能力上移到 Port，端点只依赖抽象。
- 对齐“禁止兜底/快速失败”：当 locator 存在但构建失败时，直接抛错并由端点转成 404/400（`project/backend/app/main.py:1001`），不会回退使用请求体 `world_state`。

## 如何自测
- 在 `project/backend`：
  - `./.venv/bin/python -m pytest -q tests/test_logic_check_world_state.py`（2 passed）
  - `python -m pytest -q`（95 passed）

## 原则落实（KISS / YAGNI / DRY / SOLID）
- KISS：端点只做“是否有 locator → 覆盖 world_state”这一件事，逻辑直连、最小改动。
- YAGNI：未扩展到其它调用 `gateway.logic_check` 的路径（如编排接口），避免超出工单范围的行为变更。
- DRY：存储侧复用已有 `get_scene_context` 来构建 world_state，避免重复拼装查询逻辑。
- SOLID(DIP/SRP)：端点依赖 `GraphStoragePort` 新增方法；实现放在 scene 侧 mixin，职责清晰。

## 遇到的挑战与处理
- 测试 Stub 的方法签名为关键字参数（keyword-only）：端点调用显式使用 `root_id=...` 等关键字参数以保证兼容并命中断言。

## 风险/遗留
- `build_logic_check_world_state` 复用 `get_scene_context`，其对部分场景数据存在“缺失即报错”的强约束；若未来需要在数据不完整时也允许 logic_check，需要单独定义 world_state 最小集合（本迭代按“快速失败/禁止兜底”保持严格）。

## 工具调用简报
【MCP调用简报】  
服务: serena  
触发: 代码定位（测试/端点/存储）、实现 DIP 变更、运行验收测试  
参数: `read_file`/`search_for_pattern`（限定 `project/backend`）、`execute_shell_command`（pytest）  
结果: 命中并修改 3 处（Port+GraphStorage+Endpoint）；`pytest` 全绿（2/95 passed）  
状态: 成功