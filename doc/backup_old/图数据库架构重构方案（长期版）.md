# 图数据库架构重构方案（长期版）

## 1. 背景与范围
本方案基于 `project/backend/app/storage/graph.py` 的现有实现，面向“从任意场景节点创建分支、支持提交历史、增量存储”的长期架构重构。重点覆盖：
- 分支模型从“全量复制”升级为“提交图（DAG）+ 场景版本化”。
- 读写路径改造，以分支 HEAD/Commit 作为权威来源。
- 数据迁移、兼容与回滚方案、验收标准与测试策略。

## 2. 需求确认（含边界场景）
### 2.1 核心需求
- 任意场景节点可分叉，支持无限层级分支。
- 每次用户输入产生不可变 Commit，具有父指针，可追溯历史。
- 场景内容支持多版本；不同分支可共享祖先版本。
- 分支有 HEAD 指针，支持切换到任意历史提交。
- 增量存储：新分支/新提交只保存差异。

### 2.2 边界与运维需求
- 从历史 Commit 创建新分支（不限于 HEAD）。
- 分支间同一场景的版本对比（diff）。
- 删除分支（仅删元数据与指针，不影响共享祖先数据）。
- 孤儿 Commit 的保留与清理策略（GC）。
- 分支并发提交的冲突检测与处理。
- 迁移过程支持幂等、校验与回滚。

### 2.3 “用户输入”的定义（触发 Commit 的操作）
触发 Commit 的写操作仅限：
- 场景内容变更（expected_outcome/actual_outcome/summary/rendered_content/conflict_type）。
- 场景状态变更（status/logic_exception/dirty/pov_character_id）。
- 批量场景变更（多场景一次提交）。

不触发 Commit 的操作：
- 分支创建/删除/reset（仅变更指针与元数据）。
- 读操作与查询。

说明：本方案不支持自动保存/定时提交，仅支持显式调用提交 API（KISS/YAGNI）。

### 2.4 分支命名规则
- 仅允许 `[a-zA-Z0-9._-]`，长度 1-64。
- 禁止空格与控制字符；不支持中文。
- 违反规则直接报错，不做自动清洗。

### 2.5 场景生命周期管理
- 场景新增：支持，通过 `create_scene_origin` 创建新场景，自动生成初始 SceneVersion 并产生 Commit。
- 场景删除：当前阶段不支持硬删除（YAGNI）。如需“删除”，使用 status=archived 的软删除方式并产生 Commit。
- 场景顺序：当前阶段顺序固定（由 `SceneOrigin.sequence_index` 决定），不支持重排与中间插入；新增场景仅追加到末尾。
- parent_act_id：新增场景时必须显式指定，缺失直接报错（快速失败）。

### 2.6 Act 与 Entity 的变更策略
- Act 不版本化；Act 内容（如 disaster）不可在 Phase 1/2 直接修改，调用即报错。
- Entity 的 semantic_states 在 Phase 1 不版本化；修改不会产生 Commit，也无法回滚（明确限制）。如需版本化，进入 Phase 3 引入 EntityVersion。

## 3. 现状依据（graph.py）
- `save_snowflake` 一次性创建 Root/Act/Entity/Scene 并串联 `SceneNext`（`GraphStorage.save_snowflake`）。
- `create_branch` 从 master 全量复制 Root/Act/Entity/Scene，再重建关系（`GraphStorage.create_branch`）。
- `complete_scene`、`apply_semantic_states_patch`、`mark_scene_dirty` 直接原地更新节点属性，无历史（`GraphStorage.complete_scene` / `apply_semantic_states_patch` / `mark_scene_dirty`）。
- `get_scene_context` 依赖 `SceneNext` 链表与 Scene 当前属性（`GraphStorage.get_scene_context`）。

结论：当前模型无法满足“按场景分叉、提交历史、增量存储”。

## 4. 重构目标
1. 建立 Commit DAG：每次修改形成新 Commit，支持父子关系与历史追溯。
2. 场景版本化：同一场景在不同分支/提交可有不同版本。
3. 分支 HEAD：分支指向最新 Commit，支持历史遍历。
4. 增量存储：新增内容仅存“变更”，共享祖先节点。
5. 明确分支与 reset 语义，禁止隐式分叉或自动回退。
6. 遵循 KISS/YAGNI/DRY/SOLID + 快速失败（无兜底/防御性逻辑）。

## 5. 设计概览
- 以 `Commit` 作为版本单元，形成单父 Commit 链（DAG）。
- `SceneOrigin` 表示场景身份（稳定不变），`SceneVersion` 记录场景版本。
- `BranchHead` 表示分支指针，`Branch` 记录分支元数据与派生信息。
- 新 Commit 只记录发生变化的场景版本；读取时沿祖先回溯定位版本。
- 分支与 Commit 解耦，通过关系边记录 Commit 归属。

## 6. 数据模型（新增/调整）
### 6.1 新增节点
```sql
CREATE NODE TABLE IF NOT EXISTS Commit(
  id STRING,
  parent_id STRING,
  root_id STRING,
  created_at TIMESTAMP,
  message STRING,
  PRIMARY KEY (id)
);

CREATE NODE TABLE IF NOT EXISTS SceneOrigin(
  id STRING,
  root_id STRING,
  title STRING,
  created_at TIMESTAMP,
  initial_commit_id STRING,
  sequence_index INT,
  parent_act_id STRING,
  PRIMARY KEY (id)
);

CREATE NODE TABLE IF NOT EXISTS SceneVersion(
  id STRING,
  scene_origin_id STRING,
  commit_id STRING,
  created_at TIMESTAMP,
  pov_character_id STRING,
  status STRING,
  expected_outcome STRING,
  conflict_type STRING,
  actual_outcome STRING,
  summary STRING,
  rendered_content STRING,
  logic_exception BOOLEAN,
  logic_exception_reason STRING,
  dirty BOOLEAN,
  PRIMARY KEY (id)
);

CREATE NODE TABLE IF NOT EXISTS BranchHead(
  id STRING,
  root_id STRING,
  branch_id STRING,
  head_commit_id STRING,
  fork_point_commit_id STRING,
  version INT,
  PRIMARY KEY (id)
);
```

### 6.2 关系边
```sql
CREATE REL TABLE IF NOT EXISTS CommitParent(FROM Commit TO Commit);
CREATE REL TABLE IF NOT EXISTS CommitContainsSceneVersion(FROM Commit TO SceneVersion);
CREATE REL TABLE IF NOT EXISTS BranchPointsTo(FROM BranchHead TO Commit);
CREATE REL TABLE IF NOT EXISTS OriginHasVersion(FROM SceneOrigin TO SceneVersion);
CREATE REL TABLE IF NOT EXISTS BranchContainsCommit(FROM Branch TO Commit);
CREATE REL TABLE IF NOT EXISTS RootContainsSceneOrigin(FROM Root TO SceneOrigin);
```

说明：
- `BranchContainsCommit` 仅记录分支的初始 Commit（分支创建时写入）。后续提交依赖 `CommitParent` 链，不额外写边。

### 6.3 Branch 扩展与职责分工
```sql
ALTER TABLE Branch ADD parent_branch_id STRING;
ALTER TABLE Branch ADD fork_scene_origin_id STRING;
ALTER TABLE Branch ADD fork_commit_id STRING;
```

职责分工：
- `Branch`：不变元数据（创建时间、父分支、分叉点元信息）。
- `BranchHead`：可变指针（head_commit_id、版本号）。

### 6.4 字段约束
- `Commit.message`：应用层限制最大长度 500 字符。
- `SceneOrigin.title`：迁移期允许 NULL；新建场景必须提供非空标题。
- `SceneVersion.status` 默认值由应用层填充（如 `draft`）。

说明：
- `SceneOrigin` 用于跨分支共享“场景身份”，`SceneVersion` 承载可变内容。
- `parent_act_id` 固定在 `SceneOrigin` 上，当前阶段不版本化 Act（YAGNI）。
- `Commit` 与分支解耦，通过 `BranchHead` 与 `BranchContainsCommit` 关联分支归属。
- 仅在有改动时创建新的 `SceneVersion`，保持增量存储。
- 迁移期用既有 `origin_id` 作为 `SceneOrigin.id` 的映射来源。

## 7. 核心流程与 API
### 7.1 fork_from_commit（主入口）
从历史 Commit 创建新分支：
1. 校验 `commit_id` 属于该 `root_id`。
2. 创建新 `Branch` + `BranchHead` 指向该 Commit。
3. 写入 `BranchContainsCommit` 关系。

### 7.2 fork_from_scene（语法糖）
- 根据 `scene_origin_id` + `commit_id`（可选）定位分叉 Commit。
- 未传 `commit_id` 时，默认使用 `source_branch` 当前 HEAD。
- 传入 `commit_id` 时必须满足：该 Commit 包含 `scene_origin_id` 的版本；不要求其为当前 HEAD 的祖先（允许从孤儿 Commit 分叉）。
- 内部调用 `fork_from_commit`，不新增分叉语义。

### 7.3 commit_scene（单场景）
1. 读取分支 `BranchHead` 获取 `head_commit_id` 与 `version`。
2. 计算场景内容哈希（或字段比较）；若无变化直接报错（不产生空提交）。
3. 创建新 `Commit`（parent 指向 head）。
4. 创建新 `SceneVersion` 并关联到 Commit。
5. 更新 `BranchHead`（乐观锁 compare-and-set）。

### 7.4 commit_scenes（批量）
- 支持一次提交多个场景变更，生成单个 Commit。
- 若全部无变化则报错，不生成空提交。

### 7.5 create_scene_origin（新增场景）
在当前分支创建新场景：
1. 读取当前分支最大 `sequence_index`，新场景 `sequence_index = max + 1`。
2. `parent_act_id` 必填，必须指向当前 Root 下的 Act。
3. 创建 `SceneOrigin` + 初始 `SceneVersion`。
4. 创建新 `Commit` 包含该 SceneVersion。
5. 更新 `BranchHead`。

### 7.6 delete_scene_origin（软删除）
- 不支持硬删除；使用 `status=archived` 标记并产生 Commit。
- 该操作走 `commit_scene/commit_scenes` 路径。

### 7.7 reset_branch_head（原 checkout）
- 仅允许移动到当前分支 HEAD 的祖先 Commit。
- 被回退的后续 Commit 成为孤儿，在 GC 前仍可用 `fork_from_commit` 恢复。
- 不提供 `undo_reset` API；恢复方式为显式 `fork_from_commit`。

### 7.8 get_branch_history
- 从分支 HEAD 线性回溯 Commit 链，支持 limit 参数。

### 7.9 get_commit_detail
- 返回 Commit 详情（包含本次变更的所有 SceneVersion）。

### 7.10 get_scene_at_commit
- 获取指定 Commit 时的场景内容，基于版本定位算法实现。

### 7.11 list_scene_versions
- 列出某 `scene_origin_id` 的所有版本，按 `created_at` 倒序。

### 7.12 diff_scene_versions
- 支持任意两个 Commit 的同一场景差异对比。
- 分支对比先解析到 Commit，再调用该 API。

### 7.13 delete_branch
- 删除 `Branch` 与 `BranchHead` 元数据。
- 不删除 Commit 与 SceneVersion（共享祖先可能被其他分支引用）。

### 7.14 gc_orphan_commits
- 定义“可达集合”为所有 `BranchHead.head_commit_id` 可达的 Commit。
- 删除不可达 Commit 及其关系边；无引用的 SceneVersion 可清理。
- 触发方式：仅手动调用 API；Phase 1 不做定时任务。
- 保护期：必须显式传入 `retention_days`，小于该天数的孤儿不清理。

> 快速失败原则：任何不存在的 `scene_origin_id/branch_id/commit_id` 直接抛错，不做自动降级或回退到 master。

## 8. 增量存储与版本查询算法
### 8.1 变更检测
- 比较场景字段哈希（如 `expected_outcome/summary/rendered_content` 组合）。
- 哈希一致则拒绝提交（避免无效 Commit）。

### 8.2 基础版本定位算法
```python
def get_scene_version_at_commit(scene_origin_id: str, commit_id: str) -> SceneVersion:
    current_commit = commit_id
    while current_commit:
        version = query("""
            MATCH (c:Commit)-[:CommitContainsSceneVersion]->(sv:SceneVersion)
            WHERE c.id = $commit_id AND sv.scene_origin_id = $scene_origin_id
            RETURN sv LIMIT 1
        """)
        if version:
            return version
        current_commit = get_parent_commit(current_commit)
    raise NotFound(f"Scene {scene_origin_id} not found in commit chain")
```

### 8.3 批量查询优化（可选）
```python
def get_scene_version_at_commit_fast(scene_origin_id: str, commit_id: str) -> SceneVersion:
    ancestors = get_ancestor_chain(commit_id, limit=1000)
    version = query("""
        MATCH (c:Commit)-[:CommitContainsSceneVersion]->(sv:SceneVersion)
        WHERE c.id IN $ancestor_ids AND sv.scene_origin_id = $scene_origin_id
        RETURN sv ORDER BY c.created_at DESC LIMIT 1
    """)
    if version:
        return version
    raise NotFound(...)
```

说明：Phase 1 默认使用基础算法；若性能未达标，启用批量查询优化。

## 9. 读写路径改造
- `get_scene_context`：基于 `BranchHead` + 祖先回溯定位 `SceneVersion`。
- `complete_scene` / `save_scene_render`：不再原地更新 `Scene`，统一走 `commit_scene/commit_scenes`。
- `apply_semantic_states_patch`：Phase 1 不版本化，保持原有写路径（不触发 Commit）。

## 10. 迁移方案（含兼容与回滚）
### 10.1 迁移步骤与依赖
1. **快照备份**（先决条件）。
2. **建新表**（Commit/SceneOrigin/SceneVersion/BranchHead/关系表）。
3. **生成初始 Commit**（按 root_id/branch_id）。
4. **回填场景**（Scene → SceneOrigin + SceneVersion）。
5. **建立 BranchHead**（指向初始 Commit）。
6. **建立 BranchContainsCommit**（分支与初始 Commit 关联）。
7. **切换读写路径**（显式配置，不做自动回退）。

### 10.2 迁移幂等与断点续传
- 迁移脚本需支持重复执行，已有数据不得二次写入。
- 采用明确的“已迁移标记”或存在性检查作为幂等条件。

### 10.3 sequence_index 迁移逻辑
- 通过 `SceneNext` 链表计算顺序；要求存在唯一“无前驱”场景作为起点。
- 若存在多个起点或链表成环，直接报错并终止迁移（快速失败）。

伪代码：
```python
def migrate_scene_order(root_id: str, branch_id: str) -> list[str]:
    first = find_first_scene(root_id, branch_id)  # 无前驱节点
    if not first:
        raise ValueError("No first scene")
    order = []
    current = first
    while current:
        order.append(current)
        current = get_next_scene(current)
    return order
```

### 10.4 title 迁移逻辑
- 迁移期默认写入 NULL（不做自动生成）。
- 如业务明确要求，可启用显式开关：用 `expected_outcome` 前 50 字符作为 title。

### 10.5 多分支迁移策略
- 由于旧系统不保存真实分叉历史，迁移阶段不推断分支祖先。
- 默认策略：每个分支生成独立初始 Commit，`fork_point_commit_id` 为空。
- 若业务允许手工指定（配置驱动），可在“分支与 master 完全一致”时显式设置 `fork_point_commit_id=master_initial_commit`。

### 10.6 迁移后校验
1. 每个 root_id 有且仅有一个初始 Commit。
2. 每个 Branch 有对应的 BranchHead。
3. 所有 SceneVersion.scene_origin_id 指向存在的 SceneOrigin。
4. 所有 BranchHead.head_commit_id 指向存在的 Commit。
5. SceneOrigin 数量 = 原 Scene 数量（去重后）。

### 10.7 灰度切换
- 支持按 root_id 逐步切换到新读写路径。
- 未切换的 root_id 仍使用旧路径（不混用）。

### 10.8 回滚策略
- 迁移失败：停止写入新表，恢复快照。
- 回滚后恢复旧读写路径配置。

## 11. 验收标准（量化）
### 11.1 功能验收
- 从 master 第 5 个场景创建 `branch_A`，验证 `branch_A` HEAD 与 master 前 5 个场景版本一致。
- 从 `branch_A` 的第 3 个场景创建 `branch_B`，验证二级嵌套。
- 深度嵌套：从 `branch_B` 创建 `branch_C`，再从 `branch_C` 创建 `branch_D`。
- 在 `branch_A` 提交 3 次场景修改，`get_branch_history(branch_A)` 返回 4 个 Commit（含初始）。
- 在 `branch_A` 与 `branch_B` 修改同一场景，验证 `scene_origin_id` 相同但内容不同。
- `reset_branch_head(branch_A, C2)` 后 `head_commit_id` 指向 C2，C3/C4 成为孤儿。
- 从 `branch_A` 的 C2 创建 `branch_C`，验证 `branch_C` HEAD 指向 C2。
- 从孤儿 Commit 创建分支成功，HEAD 指向该孤儿 Commit。
- 删除 `branch_A` 后，`branch_B` 的祖先数据不受影响。
- 空分支删除：创建分支后未提交任何内容，删除分支无残留。
- 并发提交：两个客户端同时提交，出现 1 成功 1 返回 `CONCURRENT_MODIFICATION`。
- 空提交拒绝：内容无变化时返回错误且不生成 Commit。
- diff：`diff_scene_versions` 返回字段级差异。
- 旧接口兼容：迁移后调用旧 `get_scene_context` 返回正确数据（内部走新模型）。

### 11.2 存储与性能
- 100 场景、10 分支、每分支改 1 场景：`SceneVersion` 总数 ≤ 110。
- 创建分支耗时 < 500ms（本地库）。
- 提交单场景耗时 < 100ms（本地库）。
- 1000 层 Commit 深度下 `get_scene_context` P50 < 100ms，P99 < 300ms。

### 11.3 数据一致性
- 不存在 `scene_origin_id` 为空的 `SceneVersion`。
- 每个 `SceneVersion` 必须属于一个 Commit（不存在孤立 SceneVersion）。
- `BranchHead.head_commit_id` 必须指向存在的 Commit。
- `Commit.parent_id` 要么为 NULL（初始），要么指向存在的 Commit。
- `BranchHead.fork_point_commit_id` 必须是 `head_commit_id` 的祖先（若不为空）。

## 12. 预期效果
### 12.1 可量化效果
- 存储量从 `B * S` 降为 `S + B * Δ`（B=分支数，S=场景数，Δ=每分支平均变更场景数）。
- 分支创建从 O(n) 全量复制降为 O(1) 元数据创建。

### 12.2 用户体验（步骤减少）
- 创建分支：从“复制全量数据 + 重建关系”简化为“一步 fork_from_commit”。
- 回溯历史：通过 `get_branch_history` + `reset_branch_head` 一步完成。
- 版本对比：使用 `diff_scene_versions` 直接得到字段差异。

## 13. 迭代计划（长期重构路径）
### Phase 1：提交图最小闭环
- 新增 Commit/SceneVersion/BranchHead 表与读写 API。
- 分支从 Commit 分叉，支持 commit + reset。

### Phase 2：读写全面迁移
- `get_scene_context`、`complete_scene`、`save_scene_render` 切换至版本模型。
- 原 `Scene` 写入路径冻结。

### Phase 3：扩展项（如需要）
- 版本化 Entity 语义状态（`EntityVersion`）。
- 场景顺序重构（如需插入/重排，再引入 `SceneOrderVersion`）。
- Act 版本化（新增 ActOrigin/ActVersion）。

## 14. 原则落地说明
- **KISS**：只引入 Commit/SceneOrigin/SceneVersion/BranchHead 四类核心概念，避免过度抽象。
- **YAGNI**：实体版本化与场景顺序重构延后到 Phase 3。
- **DRY**：统一提交入口，避免多个写入路径修改同一数据。
- **SOLID**：Commit/SceneVersion 职责单一；分支元数据与版本指针分离。

## 15. 非目标
- 不在本次长期重构中解决 SQL 参数化等安全性重构（可另立任务）。
- 不引入自动修复/容错逻辑；缺失数据一律快速失败。

## 16. 错误处理规范
### 16.1 错误码（示例）
| 错误码 | 触发条件 |
|---|---|
| BRANCH_NOT_FOUND | branch_id 无效 |
| COMMIT_NOT_FOUND | commit_id 无效 |
| SCENE_NOT_FOUND | scene_origin_id 无效 |
| BRANCH_ALREADY_EXISTS | 创建重名分支 |
| INVALID_RESET | reset 到非祖先 Commit |
| CONCURRENT_MODIFICATION | BranchHead 版本冲突 |
| INVALID_BRANCH_NAME | 分支名不符合规则 |
| INVALID_SCENE_PARENT_ACT | parent_act_id 无效 |

### 16.2 快速失败
- 所有 ID 参数必须在操作前验证存在性。
- 不做自动降级（如找不到分支不会回退到 master）。
- 不做自动修复（发现数据不一致直接报错）。

## 17. 并发控制
### 17.1 乐观锁策略
- `BranchHead` 增加 `version` 字段。
- 提交时 `WHERE version = old_version`，成功后 `version + 1`。
- 版本不匹配直接返回 `CONCURRENT_MODIFICATION`。

### 17.2 分支级写锁（可选）
- 高并发场景可引入分支级写锁。
- 读操作不加锁。

## 18. 测试策略
- **单元测试**：Commit 生成、祖先回溯、版本定位算法。
- **集成测试**：分支创建、提交、reset、diff、删除分支。
- **迁移测试**：旧数据转新表、一致性校验、回滚演练。
- **性能测试**：深度 1000 的 commit 链回溯性能。

## 19. 监控指标
- BranchHead 更新失败率（并发冲突率）。
- commit_scene 耗时与失败率。
- 版本查询耗时（get_scene_context）。
- GC 清理数量与频率。

## 20. 风险与缓解
- 深度回溯性能：启用批量查询优化；必要时引入只读缓存。
- 孤儿 Commit 堆积：定期 GC 或按策略清理。
- 并发冲突频繁：必要时引入分支级写锁。
- 迁移数据量大：分批迁移与断点续传。

## 21. 术语表
- **Commit**：一次不可变的版本快照，包含一个或多个 SceneVersion。
- **SceneOrigin**：场景的身份标识，跨分支不变。
- **SceneVersion**：场景的某个版本，属于特定 Commit。
- **BranchHead**：分支当前指针，指向最新 Commit。
- **孤儿 Commit**：不被任何 BranchHead 可达的 Commit。

## 22. FAQ
Q: 如何回到历史版本并继续编辑？
A: 使用 `fork_from_commit` 从历史 Commit 创建新分支，在新分支上编辑。

Q: reset 和 fork_from_commit 的区别？
A: reset 移动当前分支 HEAD（会产生孤儿），fork_from_commit 创建新分支（不影响原分支）。

Q: 删除分支会丢失数据吗？
A: 不会。删除分支只删除元数据，Commit 和 SceneVersion 保留（可能被其他分支共享）。

## 23. 关键伪代码示例
### 23.1 create_scene_origin
```python
def create_scene_origin(
    root_id: str,
    branch_id: str,
    title: str,
    parent_act_id: str,
    content: SceneContent,
) -> CommitResult:
    head = get_branch_head(root_id, branch_id)
    next_index = get_max_sequence_index(root_id) + 1
    origin_id = create_scene_origin_row(root_id, title, next_index, parent_act_id, head.commit_id)
    version_id = create_scene_version(origin_id, head.commit_id, content)
    commit_id = create_commit(parent_id=head.commit_id, message="create scene")
    link_commit_scene_version(commit_id, version_id)
    update_branch_head(head.id, commit_id)
    return CommitResult(commit_id=commit_id, scene_version_id=version_id)
```

### 23.2 commit_scenes
```python
def commit_scenes(root_id: str, branch_id: str, changes: list[SceneChange], message: str) -> CommitResult:
    head = get_branch_head(root_id, branch_id)
    if not has_any_change(changes):
        raise ValueError("no changes")
    commit_id = create_commit(parent_id=head.commit_id, message=message)
    for change in changes:
        version_id = create_scene_version(change.scene_origin_id, commit_id, change.content)
        link_commit_scene_version(commit_id, version_id)
    update_branch_head(head.id, commit_id)
    return CommitResult(commit_id=commit_id)
```

### 23.3 reset_branch_head
```python
def reset_branch_head(root_id: str, branch_id: str, commit_id: str) -> None:
    head = get_branch_head(root_id, branch_id)
    if not is_ancestor(commit_id, head.commit_id):
        raise ValueError("invalid reset")
    update_branch_head(head.id, commit_id)
```

### 23.4 get_scene_at_commit
```python
def get_scene_at_commit(scene_origin_id: str, commit_id: str) -> SceneVersion:
    return get_scene_version_at_commit(scene_origin_id, commit_id)
```

## 24. API 签名规范（核心）
```python
def fork_from_commit(
    root_id: str,
    source_commit_id: str,
    new_branch_id: str,
) -> BranchCreateResult:
    """从指定 Commit 创建新分支。"""


def fork_from_scene(
    root_id: str,
    source_branch_id: str,
    scene_origin_id: str,
    new_branch_id: str,
    commit_id: str | None = None,
) -> BranchCreateResult:
    """语法糖：基于场景定位 Commit 后调用 fork_from_commit。"""


def commit_scene(
    root_id: str,
    branch_id: str,
    scene_origin_id: str,
    content: SceneContent,
    message: str,
) -> CommitResult:
    """提交单场景变更，内容无变化则报错。"""


def commit_scenes(
    root_id: str,
    branch_id: str,
    changes: list[SceneChange],
    message: str,
) -> CommitResult:
    """批量提交多个场景变更。"""


def create_scene_origin(
    root_id: str,
    branch_id: str,
    title: str,
    parent_act_id: str,
    content: SceneContent,
) -> CommitResult:
    """新增场景并产生 Commit。"""


def reset_branch_head(root_id: str, branch_id: str, commit_id: str) -> None:
    """将分支 HEAD 移动到祖先 Commit。"""


def get_scene_at_commit(scene_origin_id: str, commit_id: str) -> SceneVersion:
    """获取指定 Commit 时的场景内容。"""
```

## 25. 数据模型 ER 图（简化）
```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│    Root     │────►│ SceneOrigin │────►│SceneVersion │
└─────────────┘     └─────────────┘     └──────┬──────┘
       │                    │                   │
       │                    │                   ▼
       │                    │            ┌─────────────┐
       │                    │            │   Commit    │◄───┐
       │                    │            └──────┬──────┘    │
       │                    │                   │ parent    │
       ▼                    │                   └───────────┘
┌─────────────┐             │
│   Branch    │             │
└──────┬──────┘             │
       │                    │
       ▼                    │
┌─────────────┐             │
│ BranchHead  │─────────────┘
└─────────────┘

关系边：
- Root -[RootContainsSceneOrigin]-> SceneOrigin
- SceneOrigin -[OriginHasVersion]-> SceneVersion
- Commit -[CommitContainsSceneVersion]-> SceneVersion
- Commit -[CommitParent]-> Commit
- BranchHead -[BranchPointsTo]-> Commit
- Branch -[BranchContainsCommit]-> Commit (仅初始)
```

## 附录 A. 迁移回滚清单
- 迁移前快照是否完成。
- 新表创建是否成功。
- 初始 Commit 与 BranchHead 是否建立。
- 回滚路径是否可用（恢复快照 + 恢复旧读写配置）。
