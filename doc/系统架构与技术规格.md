# AI Novel V4.0 多智能体叙事系统技术规格

**文档版本**: 4.1
**最后更新**: 2026-01-30
**系统状态**: 开发中

---

## 一、系统概述

### 1.1 产品定位

AI Novel V4.0 是一个基于多智能体推演的长篇小说智能创作系统。系统采用 **稀疏锚点 + 角色代理 + 世界裁决** 的三层架构，通过角色自主决策与 DM 裁决实现叙事涌现，取代传统的"大纲填空"模式。

### 1.2 核心理念：推演即生成

- **稀疏锚点 (Sparse Anchors)**: 仅定义少量关键剧情里程碑（数量可配置），而非大量预设场景
- **角色代理 (Character Agents)**: 基于 BDI (Belief-Desire-Intention) 模型的自主决策角色
- **世界裁决 (World Master)**: DM 引擎负责冲突仲裁、收敛控制、动态补路
- **推演生成 (Simulation-Driven)**: 多角色互动推演 → 叙事日志 → 智能渲染 → 正文

### 1.3 解决的核心问题

1. **涌现性缺失**: 通过角色自主决策产生意外剧情，而非执行预设大纲
2. **角色扁平化**: BDI 模型赋予角色独立的信念、欲望、意图，行为由内驱力决定
3. **节奏失控**: 中观层 (Act/Chapter) + 节奏监控 (info_gain) 确保叙事张力
4. **锚点不可达**: 动态补路算法生成过渡章节或软化锚点条件

### 1.4 系统组成

系统由以下核心组件构成，具体数量随功能迭代动态变化：

| 类别 | 说明 |
|------|------|
| API 端点 | 覆盖雪花流程、推演引擎、分支管理、实体管理等完整功能 |
| 图节点类型 | 结构子图、叙事子图、代理子图三层架构 |
| 图边类型 | 结构边、时序边、代理边 |
| 服务模块 | LLM 引擎、BDI 决策、DM 裁决、智能渲染等核心服务 |
| 数据模型 | 覆盖 BDI、DM 裁决、推演、反馈等业务领域 |

---

## 二、技术栈与全局约束

### 2.1 技术栈锁定

| 组件 | 技术选型 | 版本要求 |
|------|----------|----------|
| 开发语言 | Python | 3.11+ |
| Web 框架 | FastAPI | >= 0.111.0 |
| 数据验证 | Pydantic | >= 2.7.0 |
| 图数据库 | Memgraph | 最新稳定版 |
| 图数据库 ORM | GQLAlchemy | >= 1.4.0 |
| 图数据库驱动 | neo4j | >= 5.0.0, < 6.0.0 |
| HTTP 客户端 | httpx | >= 0.27.0 |
| ASGI 服务器 | uvicorn | >= 0.30.0 |
| 结构化输出 | instructor | >= 1.3.3 |

### 2.2 全局约束

**No-Go**:
- 禁止引入新 LLM SDK (必须通过 ToponeGateway)
- 禁止引入 langchain/llamaindex
- 禁止破坏现有 API 端点的兼容性

**Whitelist**: 仅允许 pyproject.toml 现有依赖 + asyncio/typing/enum/uuid/datetime (标准库)

### 2.3 LLM 服务配置

| 配置项 | 环境变量 | 默认值 |
|--------|----------|--------|
| API 密钥 | `TOPONE_API_KEY` | (必填) |
| 基础 URL | `TOPONE_BASE_URL` | `https://api.toponeapi.top` |
| 默认模型 | `TOPONE_DEFAULT_MODEL` | `gemini-3-pro-preview-11-2025` |
| 快速模型 | `TOPONE_SECONDARY_MODEL` | `gemini-3-flash-preview` |
| 超时时间 | `TOPONE_TIMEOUT_SECONDS` | 30 |

**LLM 角色分工**:
- **ARCHITECT**: 宏观规划，执行雪花法、锚点生成、幕章结构
- **REASONING**: 逻辑检察官，检测逻辑漏洞，收敛检查
- **CREATIVE**: 文学渲染，智能渲染管线
- **FLASH**: 快速处理，角色决策，状态提取

### 2.4 数据库配置

| 配置项 | 环境变量 | 默认值 |
|--------|----------|--------|
| 主机 | `MEMGRAPH_HOST` | (必填) |
| 端口 | `MEMGRAPH_PORT` | (必填) |
| 连接池最小 | `MEMGRAPH_POOL_MIN` | 10 |
| 连接池最大 | `MEMGRAPH_POOL_MAX` | 100 |
| 获取超时 | `MEMGRAPH_POOL_ACQUIRE_TIMEOUT` | 30.0 |
| 空闲超时 | `MEMGRAPH_POOL_IDLE_TIMEOUT` | 300.0 |

### 2.5 创作参数配置

系统支持用户自定义小说创作的核心参数，通过 API 请求或配置文件传递：

**结构参数**:

| 参数 | 说明 | 约束方式 |
|------|------|----------|
| 幕数量 | 故事划分的幕数 | 通过 Step5a 请求参数或 LLM 提示约束 |
| 章节数量 | 每幕或全书的章节数 | 通过 Step5b 请求参数或 LLM 提示约束 |
| 场景数量 | 场景骨架的数量范围 | 通过环境变量配置最小/最大值 |
| 锚点数量 | 稀疏锚点的数量范围 | 通过锚点生成请求参数约束 |

**内容参数**:

| 参数 | 说明 | 约束方式 |
|------|------|----------|
| 角色数量 | 主要角色的数量 | 通过 Step3 请求参数或 LLM 提示约束 |
| 章节字数 | 单章渲染的目标字数 | 通过渲染请求参数约束 |
| 推演回合数 | 单场景最大推演回合 | 通过推演请求参数约束 |

**约束传递机制**:

用户可通过以下方式传递创作约束：
1. **请求参数**: 在 API 请求的 payload 中直接指定数量参数
2. **提示约束 (prompt_constraint)**: 在请求中附加自然语言约束，由 LLM 遵循执行
3. **环境变量**: 系统级默认值配置

提示约束示例：
- "生成 3 幕结构"
- "本幕包含 4 个章节"
- "全书共 10 章，按 3-4-3 分配到三幕"
- "生成 5 个主要角色和 3 个次要角色"

---

## 三、项目拓扑

### 3.1 目录结构

```
project/backend/
├── app/
│   ├── main.py                    # FastAPI 应用入口
│   ├── models.py                  # Pydantic 数据模型
│   ├── config.py                  # 配置管理
│   ├── ports.py                   # 存储接口定义
│   ├── storage/
│   │   ├── memgraph_storage.py    # 核心存储实现
│   │   ├── schema.py              # GQLAlchemy ORM 模型
│   │   ├── temporal_edge.py       # 时序边管理
│   │   └── snapshot.py            # 快照机制
│   ├── services/
│   │   ├── world_state_service.py # 世界状态服务
│   │   ├── entity_resolver.py     # 实体消解
│   │   ├── impact_analyzer.py     # 影响分析
│   │   ├── dependency_matrix.py   # 依赖矩阵
│   │   ├── llm_engine.py          # LLM 引擎
│   │   ├── character_agent.py     # BDI 决策引擎
│   │   ├── world_master.py        # DM 裁决引擎 + 动态补路
│   │   ├── simulation_engine.py   # 推演引擎
│   │   └── smart_renderer.py      # 智能渲染管线
│   ├── llm/
│   │   ├── topone_client.py       # TopOne 客户端
│   │   ├── topone_gateway.py      # TopOne 网关
│   │   └── prompts/               # Prompt 模板目录
│   └── utils/
│       └── graph_algorithms.py    # 图算法工具
├── tests/
│   ├── unit/                      # 单元测试
│   ├── integration/               # 集成测试
│   └── performance/               # 性能测试
├── docker-compose.memgraph.yml    # Docker 配置
└── pyproject.toml                 # 项目依赖
```

### 3.2 核心服务模块

| 模块 | 职责 |
|------|------|
| `character_agent.py` | BDI 决策引擎：感知 → 审议 → 行动，角色自主决策 |
| `world_master.py` | DM 裁决引擎：冲突仲裁、收敛检查、动态补路、节奏监控 |
| `simulation_engine.py` | 推演引擎：多角色回合制推演，场景生成 |
| `smart_renderer.py` | 智能渲染：推演日志降噪、感官注入、风格渲染 |
| `feedback_detector.py` | 递归反馈：停滞检测、反馈修正、上下文更新 |
| `llm_engine.py` | LLM 引擎：雪花流程、锚点生成、幕章结构 |
| `world_state_service.py` | 世界状态：快照+增量混合查询 |
| `entity_resolver.py` | 实体消解：代词解析，Gemini Flash 集成 |
| `impact_analyzer.py` | 影响分析：受影响场景识别 |
| `dependency_matrix.py` | 依赖矩阵：影响查询优化 |

---

## 四、全局数据契约

### 4.1 三层图架构

系统图谱分为三个互联的子图：

**结构子图 (Structure Subgraph)** - 管理写作过程的版本控制
- 节点: `Root`, `Branch`, `BranchHead`, `Commit`, `SceneOrigin`, `SceneVersion`
- 节点: `Act`, `Chapter` (中观层)
- 边: `HEAD`, `PARENT`, `INCLUDES`, `OF_ORIGIN`, `CONTAINS_CHAPTER`, `CONTAINS_SCENE`

**叙事子图 (Narrative Subgraph)** - 管理故事世界观的动态演变
- 节点: `Entity`, `WorldSnapshot`, `StoryAnchor`, `Subplot`
- 边: `TemporalRelation`, `DEPENDS_ON`

**代理子图 (Agent Subgraph)** - 管理角色代理状态与推演日志
- 节点: `CharacterAgentState`, `SimulationLog`
- 边: `AGENT_OF`

### 4.2 节点类型定义

系统定义了三层子图的节点类型，具体数量随功能迭代动态变化。

#### 4.2.1 结构子图节点

**Root (故事根节点)**
```python
class Root:
    id: str              # 唯一标识 (索引)
    logline: str         # 一句话核心
    theme: str           # 核心主旨
    ending: str          # 结局
    created_at: datetime # 创建时间
```

**Branch (分支节点)**
```python
class Branch:
    id: str                    # 格式: root_id:branch_id (索引)
    root_id: str               # 所属根节点 (索引)
    branch_id: str             # 分支标识 (索引)
    parent_branch_id: str      # 父分支
    fork_scene_origin_id: str  # 分叉点场景
    fork_commit_id: str        # 分叉点提交
```

**BranchHead (分支头指针)**
```python
class BranchHead:
    id: str             # 格式: root_id:branch_id:head (索引)
    root_id: str        # 所属根节点
    branch_id: str      # 分支标识
    head_commit_id: str # 当前提交
    version: int        # 乐观锁版本号 (并发控制)
```

**Commit (提交节点)**
```python
class Commit:
    id: str              # 唯一标识 (索引)
    parent_id: str       # 父提交
    message: str         # 提交信息
    created_at: datetime # 创建时间
    root_id: str         # 所属根节点 (索引)
    branch_id: str       # 所属分支
```

**Act (幕节点)**
```python
class Act:
    id: str           # 格式: {root_id}:act:{seq} (索引)
    root_id: str      # 所属根节点 (索引)
    sequence: int     # 幕序号
    title: str        # 幕标题
    purpose: str      # 幕目的
    tone: str         # 基调: "calm"|"tense"|"climax"|"resolution"
```

**Chapter (章节点)**
```python
class Chapter:
    id: str                      # 格式: {act_id}:ch:{seq} (索引)
    act_id: str                  # 所属幕 (索引)
    sequence: int                # 章序号
    title: str                   # 章标题
    focus: str                   # 章焦点
    pov_character_id: str|None   # 视点人物
    rendered_content: str|None   # 渲染后的章节内容
    manually_edited: bool        # 是否手动编辑过 (默认 false)
    review_status: str           # 审核状态: "pending"|"approved"|"rejected" (默认 "pending")
```

**SceneOrigin (场景身份节点)**
```python
class SceneOrigin:
    id: str                # 唯一标识 (索引)
    root_id: str           # 所属根节点
    title: str             # 场景标题 (不可变)
    initial_commit_id: str # 初始提交
    sequence_index: int    # 序号 (关键索引)
    parent_act_id: str     # 所属幕
    chapter_id: str|None   # 所属章
    is_skeleton: bool      # 是否为骨架场景 (默认 false)
```

**SceneVersion (场景版本节点)**
```python
class SceneVersion:
    id: str                     # 唯一标识 (索引)
    scene_origin_id: str        # 关联场景原点 (索引)
    commit_id: str              # 关联提交 (索引)
    pov_character_id: str       # 视点人物
    status: str                 # 状态
    expected_outcome: str       # 大纲计划结果
    conflict_type: str          # 冲突类型
    actual_outcome: str         # 实际结果
    summary: str                # 摘要
    rendered_content: str       # 渲染内容
    logic_exception: bool       # 逻辑例外标记
    logic_exception_reason: str # 例外原因
    dirty: bool                 # 脏标记
    simulation_log_id: str|None # 关联推演日志
    is_simulated: bool          # 是否由推演生成 (默认 false)
    review_status: str          # 审核状态: "pending"|"approved"|"rejected" (默认 "pending")
```

#### 4.2.2 叙事子图节点

**Entity (实体节点)**
```python
class Entity:
    id: str                        # 唯一标识 (索引)
    root_id: str                   # 所属根节点
    branch_id: str                 # 所属分支 (索引)
    entity_type: str               # 类型: Character, Location, Item
    name: str                      # 名称
    tags: List[str]                # 标签
    semantic_states: Dict[str,str] # 语义状态快照
    arc_status: str                # 弧线状态
    has_agent: bool                # 是否有代理 (默认 false)
    agent_state_id: str|None       # 关联代理状态
```

**WorldSnapshot (世界状态快照)**
```python
class WorldSnapshot:
    id: str                  # 唯一标识 (索引)
    scene_version_id: str    # 关联场景版本 (索引)
    branch_id: str           # 分支标识
    scene_seq: int           # 场景序号 (索引)
    entity_states: Dict      # JSON 序列化的完整世界状态
    relations: List          # 关系列表
```

**StoryAnchor (故事锚点)**
```python
class StoryAnchor:
    id: str                    # 格式: {root_id}:anchor:{seq} (索引)
    root_id: str               # 所属根节点 (索引)
    branch_id: str             # 所属分支 (索引)
    sequence: int              # 锚点序号
    anchor_type: str           # 类型: "inciting_incident"|"midpoint"|"climax"|"resolution"|...
    description: str           # 锚点描述
    constraint_type: str       # 约束类型: "hard"|"soft"|"flexible"
    required_conditions: str   # JSON: 达成条件
    earliest_chapter_seq: int|None  # 最早可达成章节序号
    latest_chapter_seq: int|None    # 最晚应达成章节序号 (deadline)
    achieved: bool             # 是否已达成 (默认 false)
```

**Subplot (支线)**
```python
class Subplot:
    id: str               # 唯一标识 (索引)
    root_id: str          # 所属根节点 (索引)
    branch_id: str        # 所属分支 (索引)
    title: str            # 支线标题
    subplot_type: str     # 类型: "romance"|"mystery"|"rivalry"|...
    protagonist_id: str   # 主角实体 ID
    central_conflict: str # 核心冲突
    status: str           # 状态: "dormant"|"active"|"resolved" (默认 "dormant")
```

#### 4.2.3 代理子图节点

**CharacterAgentState (角色代理状态)**
```python
class CharacterAgentState:
    id: str                  # 格式: agent:{char_id} (索引)
    character_id: str        # 关联角色实体 (索引)
    branch_id: str           # 所属分支 (索引)
    beliefs: str             # JSON: 信念 (对世界的认知)
    desires: str             # JSON: 欲望列表
    intentions: str          # JSON: 意图列表
    memory: str              # JSON: 记忆列表
    private_knowledge: str   # JSON: 私有知识 (其他角色不知道的)
    last_updated_scene: int  # 最后更新场景序号
    version: int             # 版本号 (默认 1)
```

**SimulationLog (推演日志)**
```python
class SimulationLog:
    id: str                  # 格式: sim:{scene_id}:round:{n} (索引)
    scene_version_id: str    # 关联场景版本 (索引)
    round_number: int        # 回合序号
    agent_actions: str       # JSON: 角色行动列表
    dm_arbitration: str      # JSON: DM 裁决结果
    narrative_events: str    # JSON: 叙事事件列表
    sensory_seeds: str       # JSON: 感官细节种子
    convergence_score: float # 收敛分数 (0-1)
    drama_score: float       # 戏剧分数 (0-1)
    info_gain: float         # 信息增量 (0-1)
    stagnation_count: int    # 连续停滞回合数 (默认 0)
```

### 4.3 边类型定义

系统定义了结构边、叙事边、代理边三类边类型。

#### 4.3.1 结构边

```python
class HEAD(Relationship): pass           # BranchHead -> Commit
class PARENT(Relationship): pass         # Commit -> Commit
class INCLUDES(Relationship): pass       # Commit -> SceneVersion
class OF_ORIGIN(Relationship): pass      # SceneVersion -> SceneOrigin
class CONTAINS_CHAPTER(Relationship): pass  # Act -> Chapter
class CONTAINS_SCENE(Relationship): pass    # Chapter -> SceneOrigin
```

#### 4.3.2 叙事边

**TemporalRelation (时序关系边)**
```python
class TemporalRelation:
    relation_type: str       # 关系类型: HATES, LOVES, AT, HAS 等
    tension: int             # 叙事张力值 (0-100)
    start_scene_seq: int     # 生效场景序号 (索引)
    end_scene_seq: int|None  # 失效场景序号, NULL=当前有效 (索引)
    branch_id: str           # 分支标识 (索引)
    created_at: datetime     # 创建时间
    invalidated_at: datetime|None # 失效时间
```

#### 4.3.3 代理边

```python
class AGENT_OF(Relationship): pass       # CharacterAgentState -> Entity
class DEPENDS_ON(Relationship): pass     # StoryAnchor -> StoryAnchor
```

### 4.4 索引策略

系统为各类节点和边定义了索引以优化查询性能，索引随节点类型扩展动态增加。

**结构子图索引**:
- `Root(id)`
- `Branch(id)`, `Branch(root_id, branch_id)`
- `BranchHead(id)`, `BranchHead(root_id, branch_id)`
- `Commit(id)`, `Commit(root_id)`
- `Act(id)`, `Act(root_id)`
- `Chapter(id)`, `Chapter(act_id)`
- `SceneOrigin(id)`, `SceneOrigin(root_id, sequence_index)`
- `SceneVersion(id)`, `SceneVersion(scene_origin_id)`, `SceneVersion(commit_id)`

**叙事子图索引**:
- `Entity(id)`, `Entity(branch_id)`, `Entity(root_id, branch_id)`
- `WorldSnapshot(id)`, `WorldSnapshot(scene_version_id)`, `WorldSnapshot(branch_id, scene_seq)`
- `StoryAnchor(id)`, `StoryAnchor(root_id, branch_id)`
- `Subplot(id)`, `Subplot(root_id, branch_id)`

**代理子图索引**:
- `CharacterAgentState(id)`, `CharacterAgentState(character_id)`, `CharacterAgentState(branch_id)`
- `SimulationLog(id)`, `SimulationLog(scene_version_id)`

**时序边索引**:
- `TemporalRelation(branch_id, start_scene_seq)`
- `TemporalRelation(branch_id, end_scene_seq)`

### 4.5 核心 Pydantic 模型

系统定义了覆盖 BDI、DM 裁决、推演、反馈等业务领域的数据模型。

#### 4.5.1 BDI 模型

```python
class Desire(BaseModel):
    id: str
    type: Literal["short_term", "long_term", "reactive"]
    description: str
    priority: int = Field(ge=1, le=10)
    satisfaction_condition: str
    created_at_scene: int
    expires_at_scene: int|None = None

class Intention(BaseModel):
    id: str
    desire_id: str
    action_type: Literal["attack", "flee", "negotiate", "investigate", "wait", "other"]
    target: str
    expected_outcome: str
    risk_assessment: float = Field(ge=0, le=1)

class AgentAction(BaseModel):
    agent_id: str
    internal_thought: str
    action_type: str
    action_target: str
    dialogue: str|None = None
    action_description: str
```

#### 4.5.2 DM 裁决模型

```python
class ActionResult(BaseModel):
    action_id: str
    agent_id: str
    success: Literal["success", "partial", "failure"]
    reason: str
    actual_outcome: str

class DMArbitration(BaseModel):
    round_id: str
    action_results: List[ActionResult]
    conflicts_resolved: List[Dict] = []
    environment_changes: List[Dict] = []

class ConvergenceCheck(BaseModel):
    next_anchor_id: str
    distance: float = Field(ge=0, le=1)  # 0=达成, 1=偏离
    convergence_needed: bool
    suggested_action: str|None = None
```

#### 4.5.3 推演模型

```python
class SimulationRoundResult(BaseModel):
    round_id: str
    agent_actions: List[AgentAction]
    dm_arbitration: DMArbitration
    narrative_events: List[Dict]
    sensory_seeds: List[Dict]
    convergence_score: float
    drama_score: float
    info_gain: float
    stagnation_count: int

class ReplanRequest(BaseModel):
    current_scene_id: str
    target_anchor_id: str
    world_state_snapshot: Dict
    failed_conditions: List[str]

class ReplanResult(BaseModel):
    success: bool
    new_chapters: List[Dict]
    modified_anchor: Dict|None
    reason: str
```

#### 4.5.4 支线管理模型

```python
class CreateSubplotPayload(BaseModel):
    branch_id: str
    title: str
    subplot_type: str  # "romance"|"mystery"|"rivalry"|...
    protagonist_id: str
    central_conflict: str

class SubplotView(BaseModel):
    id: str
    root_id: str
    branch_id: str
    title: str
    subplot_type: str
    protagonist_id: str
    central_conflict: str
    status: str  # "dormant"|"active"|"resolved"
```

#### 4.5.5 递归反馈模型

```python
class FeedbackReport(BaseModel):
    trigger: str  # 触发原因: "stagnation"|"divergence"|...
    feedback: Dict[str, object]  # 反馈详情
    corrections: List[Dict[str, object]]  # 修正动作列表
    severity: float = Field(ge=0, le=1)  # 严重程度

class FeedbackLoopPayload(BaseModel):
    scene_context: Dict[str, object]
    rounds: List[SimulationRoundResult]

class FeedbackLoopResult(BaseModel):
    report: FeedbackReport|None
    updated_context: Dict[str, object]
```

#### 4.5.6 原有模型 (保持兼容)

**雪花流程模型**: `IdeaPayload`, `LoglinePayload`, `ScenePayload`, `Step4Result`

**分支管理模型**: `BranchView`, `BranchPayload`, `ForkFromCommitPayload`, `ForkFromScenePayload`, `ResetBranchPayload`

**实体管理模型**: `EntityView`, `EntityRelationView`, `CreateEntityPayload`, `UpsertRelationPayload`

**场景管理模型**: `SceneView`, `SceneContextView`, `SceneCompletePayload`, `SceneCompletionOrchestratePayload`, `SceneCompletionResult`, `SceneRenderResult`, `CreateSceneOriginPayload`, `CreateSceneOriginResult`, `DeleteSceneOriginPayload`, `SceneReorderPayload`, `SceneReorderResult`

**提交管理模型**: `CommitScenePayload`, `CommitResult`, `GcPayload`, `GcResult`

**视图模型**: `RootGraphView`, `StructureTreeView`, `StructureTreeActView`

---

## 五、API 端点定义

### 5.1 雪花流程 API

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/snowflake/step1` | 生成 logline 选项（数量可配置） |
| POST | `/api/v1/snowflake/step2` | 生成故事结构 (Root) |
| POST | `/api/v1/snowflake/step3` | 生成角色小传（数量可配置） |
| POST | `/api/v1/snowflake/step4` | 生成场景骨架（数量可配置） |
| POST | `/api/v1/snowflake/step5a` | 生成幕结构（数量可配置） |
| POST | `/api/v1/snowflake/step5b` | 生成章结构并分配场景（数量可配置） |

**参数约束说明**:
- Step1/3/4/5a/5b 均支持通过 `prompt_constraint` 字段传递数量约束
- 约束为软性约束，由 LLM 尽量遵循，系统不做硬性验证
- 若未指定约束，LLM 将根据故事内容自主决定合适的数量

**Step5b 场景分配**:
- Step5b 生成章节时，输入包含场景骨架列表
- LLM 根据场景的 expected_outcome 和 conflict_type 判断归属
- 输出 Chapter 时附带 scene_ids 字段，自动更新 SceneOrigin.chapter_id
- 用户可通过 API 手动调整场景归属

### 5.2 锚点管理 API

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/roots/{root_id}/anchors` | 生成稀疏锚点（数量可配置，含章节范围） |
| GET | `/api/v1/roots/{root_id}/anchors` | 列出锚点 |
| PUT | `/api/v1/anchors/{id}` | 更新锚点 |
| POST | `/api/v1/anchors/{id}/check` | 检查锚点可达性 |

**锚点类型**:
- `inciting_incident`: 开端事件，触发故事主线
- `midpoint`: 中点转折，故事方向性变化
- `climax`: 高潮，核心冲突爆发
- `resolution`: 结局，冲突解决
- 其他自定义类型：根据故事需要扩展

**约束类型**:
- `hard`: 必须达成，否则故事逻辑失败
- `soft`: 优先达成，必要时可软化条件
- `flexible`: 可替换为等效锚点

**章节范围**:
- 锚点生成时自动分配 earliest_chapter_seq 和 latest_chapter_seq
- 推演时根据章节范围判断达成时机和是否需要动态补路

### 5.3 角色代理 API

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/entities/{id}/agent/init` | 初始化角色代理 (BDI) |
| GET | `/api/v1/entities/{id}/agent/state` | 获取代理状态 |
| PUT | `/api/v1/entities/{id}/agent/desires` | 更新欲望列表 |
| POST | `/api/v1/entities/{id}/agent/decide` | 触发角色决策 |

### 5.4 DM 裁决 API

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/dm/arbitrate` | 裁决角色行动 |
| POST | `/api/v1/dm/converge` | 检查收敛状态 |
| POST | `/api/v1/dm/intervene` | DM 主动干预 |
| POST | `/api/v1/dm/replan` | 动态补路 |

### 5.5 推演引擎 API

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/simulation/round` | 单回合推演 |
| POST | `/api/v1/simulation/scene` | 完整场景推演（分支内串行） |
| GET | `/api/v1/simulation/logs/{scene_id}` | 获取推演日志 |
| POST | `/api/v1/render/scene` | 智能渲染单场景 |

**推演并发控制**:
- 同一分支内的推演操作串行执行
- 不同分支的推演可并行
- 推演前加载上一场景的 WorldSnapshot 作为初始状态
- 推演成功后批量持久化状态变更并创建新快照

### 5.6 分支管理 API

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/roots/{root_id}/branches` | 创建分支（深拷贝锚点） |
| GET | `/api/v1/roots/{root_id}/branches` | 列出分支 |
| POST | `/api/v1/roots/{root_id}/branches/{branch_id}/switch` | 切换分支 |
| POST | `/api/v1/roots/{root_id}/branches/{branch_id}/merge` | 合并分支（锚点状态不合并） |
| POST | `/api/v1/roots/{root_id}/branches/{branch_id}/revert` | 回滚分支 |
| POST | `/api/v1/roots/{root_id}/branches/fork_from_commit` | 从提交创建分支 |
| POST | `/api/v1/roots/{root_id}/branches/fork_from_scene` | 从场景创建分支 |
| POST | `/api/v1/roots/{root_id}/branches/{branch_id}/reset` | 重置分支（支持场景级回滚） |
| GET | `/api/v1/roots/{root_id}/branches/{branch_id}/history` | 获取分支历史 |

**分支与锚点隔离**:
- 分支创建时深拷贝源分支的所有 StoryAnchor 节点
- 每个分支独立维护锚点达成状态
- 分支合并时锚点状态不自动合并

### 5.7 场景管理 API

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/roots/{root_id}/scene_origins` | 创建场景 |
| POST | `/api/v1/roots/{root_id}/scenes/{scene_id}/delete` | 删除场景 |
| POST | `/api/v1/scenes/{scene_id}/complete` | 完成场景 |
| POST | `/api/v1/scenes/{scene_id}/complete/orchestrated` | 编排完成场景 (含逻辑检查) |
| POST | `/api/v1/scenes/{scene_id}/render` | 渲染场景 |
| GET | `/api/v1/scenes/{scene_id}/context` | 获取场景上下文 |
| GET | `/api/v1/scenes/{scene_id}/diff` | 比较场景版本 |
| POST | `/api/v1/scenes/{scene_id}/dirty` | 标记场景为脏 |

### 5.8 中观层 API

| 方法 | 路径 | 功能 |
|------|------|------|
| GET | `/api/v1/roots/{root_id}/acts` | 获取幕列表 |
| GET | `/api/v1/acts/{act_id}/chapters` | 获取章列表 |
| POST | `/api/v1/chapters/{chapter_id}/render` | 渲染章节内容 |
| PUT | `/api/v1/scenes/{scene_id}/review` | 更新场景审核状态 |
| PUT | `/api/v1/chapters/{chapter_id}/review` | 更新章节审核状态 |

### 5.9 实体管理 API

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/roots/{root_id}/entities` | 创建实体 |
| GET | `/api/v1/roots/{root_id}/entities` | 列出实体 |
| POST | `/api/v1/roots/{root_id}/relations` | 创建/更新关系 |

### 5.10 支线管理 API

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/roots/{root_id}/subplots` | 创建支线 |
| GET | `/api/v1/roots/{root_id}/subplots` | 列出支线 |
| POST | `/api/v1/subplots/{id}/resolve` | 解决支线 |

### 5.11 查询 API

| 方法 | 路径 | 功能 |
|------|------|------|
| GET | `/api/v1/roots/{root_id}` | 获取根节点快照 |
| GET | `/api/v1/roots/{root_id}/dirty_scenes` | 列出脏场景 |

### 5.12 提交 API

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/roots/{root_id}/branches/{branch_id}/commit` | 提交场景 |
| POST | `/api/v1/commits/gc` | 垃圾回收孤立提交 |

### 5.13 LLM 和逻辑检查 API

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/llm/topone/generate` | 调用 TopOne Gemini |
| POST | `/api/v1/logic/check` | 逻辑检查 |
| POST | `/api/v1/state/extract` | 状态提取 |
| POST | `/api/v1/state/commit` | 提交状态 |

### 5.14 递归反馈 API

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/simulation/feedback` | 递归反馈检测与修正 |

---

## 六、核心算法实现

### 6.1 BDI 决策引擎

**文件**: `app/services/character_agent.py`

**功能**: 基于 Belief-Desire-Intention 模型的角色自主决策。

**决策流程**:
```
输入: agent_id, scene_context

步骤:
1. perceive(agent_id, scene_context):
   - 更新 beliefs: world.location, others.{id}.state
   - 从场景上下文提取可观察信息
   - 返回 updated_beliefs

2. deliberate(agent_id):
   - 过滤有效欲望 (未过期)
   - 按 priority DESC 排序
   - 对 top 3 欲望: LLM 生成 intention
   - 返回 intentions 列表

3. act(agent_id, scene_context):
   - 获取 intentions
   - IF empty THEN return wait_action
   - 检查前置条件
   - LLM 生成具体行动
   - 返回 AgentAction

输出: AgentAction {agent_id, internal_thought, action_type, action_target, dialogue, action_description}
```

### 6.2 DM 裁决引擎

**文件**: `app/services/world_master.py`

**功能**: 冲突仲裁、收敛控制、动态补路、节奏监控。

**裁决流程**:
```
输入: round_id, actions[], world_state, rules

步骤:
1. detect_conflicts(actions):
   - IF both attack each other THEN conflict
   - IF same target same action THEN conflict
   - 返回 conflict_pairs[]

2. resolve_conflicts(conflict_pairs):
   - 根据能力值、位置优势等裁决胜负
   - 返回 resolution[]

3. check_action_validity(action, world_state, rules):
   - FOR rule in rules: IF violates THEN failure
   - IF power_level mismatch THEN partial
   - ELSE success
   - 返回 ActionResult

4. inject_sensory_seeds(scene_context):
   - 随机注入感官细节种子
   - 类型: weather, ambient_sound, character_gesture, object_detail
   - 返回 sensory_seeds[]

输出: DMArbitration {round_id, action_results[], conflicts_resolved[], environment_changes[]}
```

**节奏监控算法**:
```
输入: rounds[] (最近推演回合)

步骤:
1. 计算最近 3 轮的 info_gain 平均值
   avg_info_gain = mean([r.info_gain for r in rounds[-3:]])

2. IF avg_info_gain < 0.2:
   - 触发突发事件打破僵局
   - 返回 PacingAction(type="inject_incident")

3. IF is_deescalating(rounds[-3:]):
   - 冲突连续下降，强制升级
   - 返回 PacingAction(type="force_escalation")

4. ELSE:
   - 返回 PacingAction(type="continue")
```

### 6.3 动态补路算法

**文件**: `app/services/world_master.py`

**功能**: 当推演偏离锚点时，生成过渡章节或调整锚点。

**补路流程**:
```
输入: current_scene, target_anchor, world_state

步骤:
1. analyze_gap(world_state, target_anchor.required_conditions):
   - 评估当前状态与目标锚点的差距
   - 返回 gap {severity: 0-1, recoverable: bool, missing_conditions[]}

2. IF gap.severity < 0.7:
   - 生成过渡章节
   new_chapters = generate_bridge_chapters(
       from_state=world_state,
       to_conditions=target_anchor.required_conditions,
       max_chapters=3
   )
   - 返回 ReplanResult(success=true, new_chapters)

3. IF target_anchor.constraint_type == "soft":
   - 软化锚点条件
   modified = soften_anchor(target_anchor, world_state)
   - 返回 ReplanResult(success=true, modified_anchor=modified)

4. IF target_anchor.constraint_type == "flexible":
   - 替换为等效锚点
   replacement = generate_equivalent_anchor(target_anchor, world_state)
   - 返回 ReplanResult(success=true, modified_anchor=replacement)

5. ELSE:
   - 标记为不可恢复
   - 返回 ReplanResult(success=false, reason="hard_anchor_unreachable")
```

### 6.4 智能渲染管线

**文件**: `app/services/smart_renderer.py`

**功能**: 将推演日志转化为文学正文，解决"推演→正文"的风格断层。

**渲染流程**:
```
输入: rounds[], scene

步骤:
1. extract_narrative_beats(rounds):
   - 过滤 info_gain < 0.1 的回合
   - 移除 action_result.success == "failure" 且无戏剧价值的动作
   - 合并连续的 "wait" 动作
   - 保留所有对话和关键冲突
   - 返回 clean_beats[]

2. collect_sensory_seeds(rounds):
   - 收集所有感官细节种子
   - 按类型分组: weather, gesture, ambient, object
   - 返回 sensory_details{}

3. get_style_context(scene_id):
   - 检索前文伏笔
   - 获取角色语气 (voice_dna)
   - 确定场景基调
   - 返回 style_context{}

4. generate_prose(beats, sensory, style, pov):
   - LLM 渲染正文
   - 融入感官细节
   - 保持角色语气一致
   - 返回 content

5. check_continuity_errors(content, scene):
   - 检查角色位置、物品状态、时间线、已知信息
   - IF errors THEN fix_continuity(content)
   - 返回 final_content
```

### 6.5 递归反馈检测算法

**文件**: `app/services/feedback_detector.py`

**功能**: 检测推演过程中的停滞、偏离等问题，生成修正动作并更新场景上下文。

**检测流程**:
```
输入: scene_context, rounds[]

步骤:
1. detect_feedback(rounds):
   latest = rounds[-1]
   IF latest.stagnation_count >= 3:
     severity = min(1.0, 0.5 + 0.1 * stagnation_count)
     返回 FeedbackReport(
       trigger="stagnation",
       feedback={info_gain, stagnation_count},
       corrections=[{action: "inject_incident"}],
       severity
     )
   返回 None

2. process_feedback(scene_context, rounds):
   report = detect_feedback(rounds)
   updated_context = copy(scene_context)
   IF report is None:
     返回 (None, updated_context)
   FOR correction in report.corrections:
     action = correction["action"]
     updated_context["events"].append({type: "feedback", action})
   返回 (report, updated_context)

输出: FeedbackLoopResult {report, updated_context}
```

**触发条件**:
| 触发器 | 条件 | 严重程度 | 修正动作 |
|--------|------|----------|----------|
| stagnation | stagnation_count >= 3 | 0.5-1.0 | inject_incident |
| divergence | distance > 0.9 | 0.7-1.0 | force_convergence |
| repetition | 连续 3 轮相同行动 | 0.3-0.6 | vary_action |

### 6.6 时序边管理算法

**文件**: `app/storage/temporal_edge.py`

**功能**: 追踪实体状态的完整变化历史，支持时间旅行查询。

**创建/更新关系算法**:
```
输入: from_entity_id, to_entity_id, relation_type, tension, scene_seq, branch_id

步骤:
1. 查找所有活跃的同类型关系:
   WHERE start_scene_seq <= current_seq AND end_scene_seq IS NULL
2. 将这些关系的 end_scene_seq 设置为 current_seq (失效旧边)
3. 创建新关系:
   start_scene_seq = current_seq
   end_scene_seq = NULL
4. 使用事务保证原子性
```

**时间旅行查询算法**:
```
输入: from_entity_id, branch_id, target_scene_seq

查询条件:
WHERE r.branch_id = $branch_id
  AND r.start_scene_seq <= $target_scene_seq
  AND (r.end_scene_seq IS NULL OR r.end_scene_seq > $target_scene_seq)

返回: 该时间点的所有活跃关系
```

### 6.7 快照机制算法

**文件**: `app/storage/snapshot.py`

**功能**: 优化历史状态查询性能，避免遍历所有时序边。

**快照创建规则**:
```python
def should_create_snapshot(scene_seq: int) -> bool:
    return scene_seq > 0 and scene_seq % 10 == 0
```

**世界状态查询优化算法**:
```
输入: branch_id, target_scene_seq

步骤:
1. 计算最近快照点: snapshot_seq = (target_seq // 10) * 10
2. 查询快照节点获取基础状态
3. 如果 snapshot_seq < target_seq:
   - 查询增量变更: start_seq > snapshot_seq AND start_seq <= target_seq
   - 应用增量变更到基础状态
4. 返回完整世界状态

复杂度分析:
- 最坏情况: O(E×10) - 从快照回放 10 个场景
- 最好情况: O(1) - 直接命中快照
- 平均情况: O(E×5)
```

### 6.8 收敛检查算法

**文件**: `app/services/world_master.py`

**功能**: 评估当前世界状态与下一个锚点的距离。

**收敛检查流程**:
```
输入: world_state, next_anchor

步骤:
1. LLM 评估距离 (0-1):
   - 0 = 锚点已达成
   - 1 = 完全偏离

2. IF distance > 0.7 THEN convergence_needed = true

3. generate_convergence_action(distance, world_state):
   - distance < 0.5: npc_hint (NPC 暗示)
   - distance < 0.7: environment_pressure (环境压力)
   - distance < 0.9: deus_ex_machina (机械降神)
   - distance >= 0.9: trigger replan_route() (动态补路)

输出: ConvergenceCheck {next_anchor_id, distance, convergence_needed, suggested_action}
```

---

## 七、业务流程

### 7.1 雪花流程数据流

```
用户想法
  ↓
Step 1: POST /api/v1/snowflake/step1
  → 生成 logline 选项（数量可配置）
  ↓
用户选择 logline
  ↓
Step 2: POST /api/v1/snowflake/step2
  → 扩展成故事结构 (Root)
  ├─ logline
  ├─ three_disasters
  ├─ ending
  └─ theme
  ↓
Step 3: POST /api/v1/snowflake/step3
  → 生成角色小传（数量可配置）
  ├─ name, ambition, conflict, epiphany, voice_dna
  └─ 验证角色与主线冲突
  ↓
Step 4: POST /api/v1/snowflake/step4
  → 生成场景骨架（数量可配置）
  ↓
Step 5a: POST /api/v1/snowflake/step5a
  → 生成幕结构（数量可配置）
  ├─ title, purpose, tone
  └─ 保存 Act 节点
  ↓
Step 5b: POST /api/v1/snowflake/step5b
  → 生成章结构（数量可配置）
  ├─ title, focus, pov_character_id
  └─ 保存 Chapter 节点，关联 Act
  ↓
Root + Characters + Acts + Chapters 持久化
```

### 7.2 锚点生成数据流

```
雪花流程完成后
  ↓
POST /api/v1/roots/{root_id}/anchors
  → 生成稀疏锚点（数量可配置）
  ├─ 建议包含: inciting_incident, midpoint, climax, resolution
  ├─ 每个锚点: anchor_type, description, constraint_type, required_conditions
  ├─ 章节范围分配: earliest_chapter_seq, latest_chapter_seq
  └─ 保存 StoryAnchor 节点
  ↓
锚点依赖关系
  → 创建 DEPENDS_ON 边
  ↓
锚点系统就绪，等待推演
```

### 7.3 角色代理初始化数据流

```
角色实体创建后
  ↓
POST /api/v1/entities/{id}/agent/init
  → 初始化 BDI 代理
  ├─ 从角色小传提取初始 beliefs
  ├─ 从 ambition/conflict 生成初始 desires
  ├─ intentions = []
  ├─ memory = []
  └─ private_knowledge = []
  ↓
创建 CharacterAgentState 节点
  → 创建 AGENT_OF 边
  → 更新 Entity: has_agent=true
  ↓
角色代理就绪，可参与推演
```

### 7.4 场景推演数据流 (核心流程)

```
场景骨架 (SceneOrigin)
  ↓
POST /api/v1/simulation/scene
  → 启动场景推演（同一分支内串行执行）
  ↓
FOR round in range(max_rounds):
  │
  ├─ 1. 角色决策 (并行)
  │   FOR agent in scene_agents:
  │     └─ agent.decide(scene_context) → AgentAction
  │
  ├─ 2. DM 裁决
  │   └─ world_master.arbitrate(actions) → DMArbitration
  │       ├─ 冲突检测与解决
  │       ├─ 行动有效性检查
  │       ├─ 环境变化生成
  │       └─ 感官种子注入
  │
  ├─ 3. 状态更新
  │   ├─ 更新 agent beliefs/memory
  │   ├─ 更新 world_state（暂存内存）
  │   └─ 创建 TemporalRelation (时序边)
  │
  ├─ 4. 节奏监控
  │   └─ world_master.monitor_pacing(rounds)
  │       ├─ IF stagnation → inject_incident
  │       └─ IF deescalating → force_escalation
  │
  ├─ 5. 收敛检查
  │   └─ world_master.check_convergence(world_state, next_anchor)
  │       ├─ IF distance > 0.9 → trigger replan_route()
  │       └─ ELSE → apply convergence_action
  │
  └─ 6. 结束判断
      └─ IF should_end_scene(round) THEN break
  ↓
推演完成
  ├─ 生成 SimulationLog
  ├─ 创建 WorldSnapshot（批量持久化状态变更）
  └─ 检测锚点达成条件
  ↓
SceneVersion (is_simulated=true, review_status="pending")
```

### 7.5 动态补路数据流

```
收敛检查发现 distance >= 0.9
  ↓
POST /api/v1/dm/replan
  → 动态补路
  ↓
analyze_gap(world_state, target_anchor)
  ├─ severity < 0.7 → 生成过渡章节
  │   └─ 插入 1-3 个 bridge chapters
  │
  ├─ constraint_type == "soft" → 软化锚点
  │   └─ 放宽 required_conditions
  │
  ├─ constraint_type == "flexible" → 替换锚点
  │   └─ 生成等效锚点
  │
  └─ constraint_type == "hard" → 标记不可恢复
      └─ 需人工介入
  ↓
ReplanResult {success, new_chapters, modified_anchor, reason}
```

### 7.6 锚点达成数据流

```
推演过程中（每场景结束后）
  ↓
check_anchor_conditions(world_state, anchor)
  → 检查锚点条件是否满足
  ↓
获取当前章节序号 current_chapter_seq
  ↓
IF all conditions met AND current_chapter_seq >= anchor.earliest_chapter_seq:
  ├─ mark_anchor_achieved(anchor_id, scene_version_id)
  ├─ 更新锚点状态 achieved=true
  └─ 获取下一个未达成锚点
  ↓
IF current_chapter_seq > anchor.latest_chapter_seq AND NOT achieved:
  └─ 触发动态补路 replan_route()
  ↓
继续推演直到所有锚点达成或故事结束
```

### 7.7 章节渲染数据流

```
章节内所有场景推演完成后
  ↓
POST /api/v1/chapters/{chapter_id}/render
  → 章节批量渲染
  ↓
收集章节内所有场景的 SimulationLog
  ↓
智能渲染管线
  ├─ 降噪: 过滤无效回合
  ├─ 场景过渡: 处理场景间衔接
  ├─ 感官注入: 融入 sensory_seeds
  ├─ 风格渲染: 保持角色语气
  └─ 一致性检查
  ↓
自动质量评估
  ├─ coherence_score: 前后文连贯性
  ├─ character_consistency: 角色行为一致性
  ├─ word_count: 字数检查
  └─ repetition_ratio: 重复内容比例
  ↓
IF quality_scores < threshold:
  └─ 自动重试（最多 N 次）
  ↓
Chapter (rendered_content, review_status="pending")
  ↓
人工审核
  ├─ approved → 章节完成
  └─ rejected → 触发重新渲染或手动编辑
```

---

## 八、性能指标

### 8.1 推演性能目标

| 指标 | 目标值 | 说明 |
|------|--------|------|
| 单回合推演延迟 (P95) | < 2s | 含角色决策 + DM 裁决 |
| 单场景推演延迟 (P95) | < 10s | 含多回合推演 + 渲染 |
| 角色行为一致性 | > 85% | BDI 约束下的行为合理性 |
| 锚点达成率 | > 90% | 稀疏锚点最终达成比例 |
| 收束成功率 | > 95% | DM 干预后回归轨道比例 |
| 平均 info_gain/回合 | > 0.3 | 信息增量，避免水文 |
| 渲染后正文质量评分 | > 4.0/5.0 | 人工评估 |
| 动态补路成功率 | > 80% | 锚点不可达时的恢复率 |

### 8.2 查询性能目标

| 指标 | 目标值 | 说明 |
|------|--------|------|
| 简单查询延迟 (P95) | < 200ms | 单节点/单边查询 |
| 复杂查询延迟 (P95) | < 500ms | 时序范围/多跳遍历 |
| 快照直接命中 (P95) | < 100ms | 快照查询 |
| 写操作延迟 (P95) | < 300ms | 含事务提交 |

### 8.3 吞吐量与并发目标

| 指标 | 目标值 | 说明 |
|------|--------|------|
| 吞吐量 | > 50 QPS | 混合读写 |
| 并发用户数 | > 50 | 保守估计 |
| 内存占用 | < 20GB | 32GB 配置下 |
| 连接池获取时间 | < 10ms | 平均值 |
| 缓存命中率 | > 80% | 实体/关系缓存 |

### 8.4 LLM 调用性能目标

| 指标 | 目标值 | 说明 |
|------|--------|------|
| 角色决策延迟 (P95) | < 1s | 使用 Flash 模型 |
| DM 裁决延迟 (P95) | < 1.5s | 使用 Pro 模型 |
| 智能渲染延迟 (P95) | < 3s | 使用 Creative 模型 |
| 并行角色决策 | 支持 5+ | 同时处理多角色 |

### 8.5 可扩展性目标

| 指标 | 目标值 |
|------|--------|
| 支持故事数 | 1000+ |
| 支持场景数 | 10000+ |
| 支持实体数 | 1000+ |
| 支持角色代理数 | 50+/故事 |
| 支持锚点数 | 100+/故事 |
| 支持并发用户 | 100+ |

---

## 九、测试规范

### 9.1 测试分层

| 层级 | 目录 | 职责 |
|------|------|------|
| 单元测试 | `tests/unit/` | ORM 模型验证，BDI 逻辑，DM 算法 |
| 集成测试 | `tests/integration/` | GraphStorage + Memgraph, 推演流程 |
| 性能测试 | `tests/performance/` | 压测，基准测试 |

### 9.2 测试覆盖范围

**单元测试 (tests/unit/)**:
- 节点模型验证：Act, Chapter, StoryAnchor, CharacterAgentState, SimulationLog, Subplot
- 数据模型验证：BDI 模型、DM 裁决模型、反馈模型
- 核心算法测试：BDI 决策引擎、DM 裁决引擎、动态补路、智能渲染、递归反馈检测
- Prompt 模板验证

**集成测试 (tests/integration/)**:
- 存储层 CRUD：幕章存储、锚点存储、代理状态存储、支线存储
- 完整流程测试：推演流程、节奏监控、递归反馈、雪花流程
- API 端点测试：锚点 API、代理 API、DM API、推演 API、支线 API

### 9.3 核心测试用例

**测试 1: BDI 决策流程**
```
Given: 角色代理 (beliefs: {enemy_nearby: true}, desires: [{type: "reactive", priority: 9, desc: "survive"}])
When: agent.decide(scene_context)
Then: 返回 AgentAction(action_type="flee" or "attack")
```

**测试 2: DM 冲突裁决**
```
Given: actions = [A attacks B, B attacks A]
When: world_master.arbitrate(actions)
Then: 返回 DMArbitration 包含 1 个 conflict_resolved
```

**测试 3: 节奏监控触发**
```
Given: rounds[-3:] 的 info_gain 均 < 0.1
When: world_master.monitor_pacing(rounds)
Then: 返回 PacingAction(type="inject_incident")
```

**测试 4: 动态补路 - 生成过渡章节**
```
Given: gap.severity = 0.5, target_anchor.constraint_type = "hard"
When: replan_route(current_scene, target_anchor, world_state)
Then: 返回 ReplanResult(success=true, new_chapters=[...])
```

**测试 5: 动态补路 - 软化锚点**
```
Given: gap.severity = 0.8, target_anchor.constraint_type = "soft"
When: replan_route(current_scene, target_anchor, world_state)
Then: 返回 ReplanResult(success=true, modified_anchor={...})
```

**测试 6: 智能渲染降噪**
```
Given: rounds 包含 3 个 info_gain < 0.1 的回合
When: smart_renderer.render(rounds, scene)
Then: 输出内容不包含这些回合的细节
```

**测试 7: 感官种子注入**
```
Given: rounds 包含 sensory_seeds = [{type: "weather", detail: "暴雨"}]
When: smart_renderer.render(rounds, scene)
Then: 输出内容包含天气描写
```

**测试 8: 锚点达成检测**
```
Given: anchor.required_conditions = ["hero_has_sword"]
       world_state.entities["hero"].has = ["sword"]
When: check_anchor_conditions(world_state, anchor)
Then: 返回 true, 触发 mark_anchor_achieved
```

**测试 9: 递归反馈检测 - 停滞触发**
```
Given: rounds[-1].stagnation_count = 3
When: feedback_detector.detect_feedback(rounds)
Then: 返回 FeedbackReport(trigger="stagnation", severity>=0.5, corrections=[{action: "inject_incident"}])
```

**测试 10: 递归反馈处理 - 上下文更新**
```
Given: scene_context = {events: []}, rounds[-1].stagnation_count = 4
When: feedback_detector.process_feedback(scene_context, rounds)
Then: updated_context.events 包含 {type: "feedback", action: "inject_incident"}
```

**测试 11: 支线创建**
```
Given: root_id, branch_id, subplot_data = {title: "暗恋", subplot_type: "romance", protagonist_id: "char_1"}
When: POST /api/v1/roots/{root_id}/subplots
Then: 返回 SubplotView(status="dormant")
```

**测试 12: 支线解决**
```
Given: subplot.status = "active"
When: POST /api/v1/subplots/{id}/resolve
Then: subplot.status = "resolved"
```

### 9.4 测试覆盖率目标

| 模块 | 单元测试 | 集成测试 |
|------|----------|----------|
| CharacterAgentEngine | > 80% | > 70% |
| WorldMasterEngine | > 80% | > 70% |
| SimulationEngine | > 75% | > 80% |
| SmartRenderer | > 75% | > 70% |
| GraphStorage | > 80% | > 70% |
| API Endpoints | > 60% | > 75% |

### 9.5 测试执行命令

```bash
# 运行所有测试
pytest -q -rs

# 运行新增模块测试
pytest -q -k "agent or simulation or anchor or renderer"

# 运行集成测试
pytest -q tests/integration/

# 运行性能测试
pytest -q -k benchmark

# 运行覆盖率报告
pytest --cov=app --cov-report=html
```

---

## 十、部署配置

### 10.1 Docker 部署

```bash
# 启动 Memgraph
docker compose -f project/backend/docker-compose.memgraph.yml up -d

# 启动应用
uvicorn app.main:app --host 0.0.0.0 --port 8000
```

### 10.2 环境变量配置

```bash
# 必填配置
export MEMGRAPH_HOST=localhost
export MEMGRAPH_PORT=7687
export TOPONE_API_KEY=your_key

# 可选配置
export MEMGRAPH_POOL_MIN=10
export MEMGRAPH_POOL_MAX=100
export MEMGRAPH_POOL_ACQUIRE_TIMEOUT=30.0
export MEMGRAPH_POOL_IDLE_TIMEOUT=300.0
export TOPONE_TIMEOUT_SECONDS=30
```

### 10.3 连接池配置

| 参数 | 默认值 | 说明 |
|------|--------|------|
| min_size | 10 | 最小连接数 |
| max_size | 100 | 最大连接数 |
| acquire_timeout | 30s | 获取连接超时 |
| idle_timeout | 300s | 空闲连接超时 |

### 10.4 缓存配置

系统使用三层缓存架构:
- `_entity_cache`: 实体缓存 (root_id, branch_id) -> 实体列表
- `_character_cache`: 角色缓存 (root_id, branch_id) -> 角色列表
- `_agent_state_cache`: 代理状态缓存 (agent_id) -> AgentState

缓存使用线程锁保护，支持并发安全访问。

---

## 十一、错误处理

### 11.1 API 错误码

| 状态码 | 场景 | 示例 |
|--------|------|------|
| 400 | 输入验证失败 | Desire.priority 超出 1-10 范围 |
| 404 | 资源不存在 | 锚点/代理/场景不存在 |
| 409 | 冲突 | 代理已存在，锚点已达成 |
| 422 | 业务逻辑错误 | 硬锚点不可达 |
| 500 | 服务器错误 | 数据库连接失败 |

### 11.2 推演错误处理

| 错误类型 | 处理策略 |
|----------|----------|
| 角色决策超时 | 直接失败并上报（中断本回合） |
| DM 裁决失败 | 直接失败并上报（中断本回合） |
| 收敛检查失败 | 直接失败并上报 |
| 动态补路失败 | 直接失败并上报 |
| 渲染失败 | 直接失败并上报 |

### 11.3 并发冲突处理

**分支级串行推演**:
- 同一分支内的推演操作串行执行（使用分支级锁）
- 不同分支的推演可并行（分支间状态隔离）

**乐观锁机制**:
1. BranchHead 节点包含 version 字段
2. CharacterAgentState 节点包含 version 字段
3. 更新前查询当前 version
4. 更新时检查 version 是否匹配
5. 不匹配则抛出 `ConcurrentModificationError`

---

## 十二、监控与告警

### 12.1 关键监控指标

- API 响应时间 (P50, P95, P99)
- 推演回合延迟
- 角色决策延迟
- DM 裁决延迟
- 智能渲染延迟
- 锚点达成率
- 收敛成功率
- 动态补路触发次数
- LLM API 调用次数和成功率
- 错误率

### 12.2 告警规则

| 指标 | Warning | Critical |
|------|---------|----------|
| 推演回合延迟 P99 | > 3s | > 5s |
| 角色决策失败率 | > 5% | > 15% |
| 锚点达成率 | < 85% | < 70% |
| 收敛成功率 | < 90% | < 80% |
| 内存占用 | > 25GB | > 30GB |
| 连接池使用率 | > 80% | > 95% |

### 12.3 日志级别

- **DEBUG**: 详细的推演过程，角色决策细节
- **INFO**: 重要事件 (场景推演开始/结束、锚点达成)
- **WARNING**: 潜在问题 (节奏停滞、收敛困难)
- **ERROR**: 错误情况 (推演失败、补路失败)

---

## 附录 A: BDI 角色决策 Prompt 设计

```text
你是角色 {character_name}，正在场景 {scene_title} 中行动。

## 你的身份
- 名字: {name}
- 野心: {ambition}
- 内心冲突: {conflict}
- 语气特征: {voice_dna}

## 你当前的认知 (Beliefs)
{beliefs_json}

## 你的欲望 (Desires)
{desires_json}

## 当前场景
{scene_context}

## 任务
基于你的性格、认知和欲望，决定你在这个场景中的行动。

输出格式 (JSON):
{
  "internal_thought": "你的内心独白，不超过50字",
  "action_type": "attack|flee|negotiate|investigate|wait|other",
  "action_target": "行动目标",
  "dialogue": "你说的话（可选）",
  "action_description": "你的具体行动描述"
}

注意：
1. 行动必须符合你的性格和当前认知
2. 不要做出你不知道的信息相关的行动
3. 优先满足高优先级的欲望
```

---

## 附录 B: DM 裁决 Prompt 设计

```text
你是这个故事世界的裁决者 (Dungeon Master)。你的任务是裁决角色行动的结果。

## 世界规则
{world_rules}

## 当前世界状态
{world_state_json}

## 本回合角色行动
{actions_json}

## 任务
1. 检测行动之间的冲突
2. 裁决每个行动的成功/失败/部分成功
3. 生成环境变化
4. 注入 1-2 个感官细节种子

输出格式 (JSON):
{
  "action_results": [
    {"action_id": "...", "agent_id": "...", "success": "success|partial|failure", "reason": "...", "actual_outcome": "..."}
  ],
  "conflicts_resolved": [
    {"agents": ["a1", "a2"], "resolution": "..."}
  ],
  "environment_changes": [
    {"type": "...", "description": "..."}
  ],
  "sensory_seeds": [
    {"type": "weather|gesture|ambient|object", "detail": "...", "char_id": "...（可选）"}
  ]
}

裁决原则：
1. 能力值高的角色更容易成功
2. 位置优势影响结果
3. 意外因素可以改变结果（但要合理）
4. 感官细节要与场景氛围一致
```

---

## 附录 C: 智能渲染 Prompt 设计

```text
你是一位文学渲染专家。将推演日志转化为小说正文。

## 场景信息
- 标题: {scene_title}
- 视点人物: {pov_character}
- 基调: {tone}

## 推演日志 (已降噪)
{narrative_beats_json}

## 感官细节种子
{sensory_seeds_json}

## 风格上下文
- 前文伏笔: {foreshadowing}
- 角色语气: {voice_dna}

## 任务
将推演日志渲染为文学正文，要求：
1. 使用第三人称限制视角（{pov_character} 的视角）
2. 融入感官细节种子，但不要生硬
3. 保持角色语气一致
4. 对话要符合角色性格
5. 不要添加推演日志中没有的情节

输出：纯文本小说正文（字数可配置）
```

---

## 附录 D: 收敛检查 Prompt 设计

```text
你是故事收敛评估专家。评估当前世界状态与目标锚点的距离。

## 目标锚点
- 类型: {anchor_type}
- 描述: {anchor_description}
- 达成条件: {required_conditions}

## 当前世界状态
{world_state_json}

## 任务
评估当前状态距离锚点达成还有多远。

输出格式 (JSON):
{
  "distance": 0.0-1.0,  // 0=已达成, 1=完全偏离
  "analysis": "分析说明",
  "missing_conditions": ["缺失的条件1", "缺失的条件2"],
  "suggested_action": "建议的收敛行动（如果需要）"
}

评估标准：
- 0.0-0.3: 接近达成，自然发展即可
- 0.3-0.5: 需要轻微引导 (NPC 暗示)
- 0.5-0.7: 需要中度干预 (环境压力)
- 0.7-0.9: 需要强力干预 (突发事件)
- 0.9-1.0: 严重偏离，需要动态补路
```

---

## 附录 E: 相关文档索引

| 文档 | 路径 | 说明 |
|------|------|------|
| 实施协议 | `doc/multi_agent_narrative_system_plan.md` | 多智能体系统实施步骤 |

---

## 附录 F: 设计决策

以下是系统关键设计点的确定方案。

### F.1 场景与章节映射

**方案**: LLM 智能分配 + 手动调整

**实现要点**:
1. Step5b 生成章节时，输入包含场景骨架列表
2. LLM 根据场景的 expected_outcome 和 conflict_type 判断归属
3. 输出 Chapter 时附带 scene_ids 字段
4. 用户可通过 API 手动调整场景归属
5. 每章场景数量由 LLM 根据内容密度自主决定

**数据模型**: SceneOrigin 已有 chapter_id 字段，无需新增

---

### F.2 锚点与章节关联

**方案**: 锚点关联目标章节范围，推演时动态检测达成

**实现要点**:
1. StoryAnchor 包含章节范围字段：
   - `earliest_chapter_seq`: 最早可达成的章节序号
   - `latest_chapter_seq`: 最晚应达成的章节序号（即 deadline）
2. 锚点生成时，LLM 根据故事结构分配章节范围
3. 推演过程中，每场景结束后检测锚点条件
4. 达成时机判断：
   - 条件满足 + 当前章节 >= earliest_chapter_seq → 标记达成
   - 当前章节 > latest_chapter_seq + 条件未满足 → 触发动态补路
5. 同一章节多锚点达成：按 sequence 顺序依次标记

**数据模型**: StoryAnchor 使用 earliest_chapter_seq 和 latest_chapter_seq 字段

---

### F.3 推演与渲染的衔接

**方案**: 按场景推演，按章节批量渲染

**实现要点**:
1. **推演阶段**：逐场景推演，每场景生成 SimulationLog
2. **渲染阶段**：
   - 收集章节内所有场景的 SimulationLog
   - 智能渲染管线接收场景列表，输出完整章节内容
   - 渲染时处理场景间过渡，确保叙事连贯
3. **修订流程**：
   - 渲染结果存入 Chapter 的 `rendered_content` 字段
   - 用户可通过 API 触发重新渲染或手动编辑
   - 编辑后内容标记为 `manually_edited=true`，后续重渲染需确认覆盖

**API 变更**: 新增 `POST /api/v1/chapters/{chapter_id}/render` 端点

---

### F.4 分支与锚点的一致性

**方案**: 锚点按分支隔离，分支创建时深拷贝

**实现要点**:
1. **分支创建时**：
   - 深拷贝源分支的所有 StoryAnchor 节点
   - 新锚点的 branch_id 设为新分支 ID
   - achieved 状态保持与源分支一致
2. **分支合并时**：
   - 锚点状态不自动合并（锚点是叙事约束，非内容）
   - 合并后保留目标分支的锚点状态
   - 若需同步，用户手动触发锚点状态更新
3. **分支隔离保证**：
   - 所有锚点查询必须带 branch_id 过滤
   - 锚点达成标记仅影响当前分支

**数据模型**: StoryAnchor 已有 branch_id 字段，无需变更

---

### F.5 世界状态的一致性保证

**方案**: 单分支串行推演 + 场景级快照

**实现要点**:
1. **并发控制**：
   - 同一分支内的推演操作串行执行（使用分支级锁）
   - 不同分支的推演可并行（分支间状态隔离）
   - BranchHead.version 字段用于乐观锁检测
2. **状态快照**：
   - 每场景推演完成后创建 WorldSnapshot
   - 快照包含该时刻所有实体状态和关系
   - 支持回滚到任意场景的状态
3. **跨场景依赖**：
   - 推演前加载上一场景的 WorldSnapshot 作为初始状态
   - 推演过程中的状态变更暂存于内存
   - 推演成功后批量持久化状态变更
4. **回滚机制**：
   - 场景级回滚：删除目标场景后的所有 SceneVersion 和 WorldSnapshot
   - 通过分支重置 API 实现

**性能考虑**: 快照每 N 个场景创建一次（N 可配置），中间场景通过增量重放恢复

---

### F.6 内容质量控制

**方案**: 多维度自动评估 + 阈值重试 + 人工审核节点

**实现要点**:
1. **自动评估指标**：
   - `coherence_score`: 前后文连贯性（LLM 评估）
   - `character_consistency`: 角色行为一致性（对比 BDI 状态）
   - `word_count`: 字数是否在目标范围内
   - `repetition_ratio`: 重复内容比例
2. **阈值重试机制**：
   - 渲染后自动评估，低于阈值则重试（最多 N 次）
   - 重试时调整 temperature 或补充上下文
   - 超过重试次数则标记为需人工审核
3. **人工审核节点**：
   - SceneVersion 和 Chapter 包含 `review_status` 字段：`pending`/`approved`/`rejected`
   - 标记为 rejected 的内容可触发重新推演或渲染
   - 提供批量审核 API 支持高效处理
4. **质量报告**：
   - 每章节生成质量评估报告
   - 汇总到故事级别的质量仪表盘

**API 变更**:
- 渲染 API 返回值增加 quality_scores 字段
- `PUT /api/v1/scenes/{scene_id}/review` 审核端点
- `PUT /api/v1/chapters/{chapter_id}/review` 审核端点

---

**文档维护说明**: 本文档描述 AI Novel V4.0 多智能体叙事系统的完整技术规格。如有架构变更，请同步更新本文档与实施协议。
