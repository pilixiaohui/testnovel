# AI Novel V4.0 多智能体叙事系统技术规格

**文档版本**: 4.0
**最后更新**: 2026-01-24
**系统状态**: 开发中

---

## 一、系统概述

### 1.1 产品定位

AI Novel V4.0 是一个基于多智能体推演的长篇小说智能创作系统。系统采用 **稀疏锚点 + 角色代理 + 世界裁决** 的三层架构，通过角色自主决策与 DM 裁决实现叙事涌现，取代传统的"大纲填空"模式。

### 1.2 核心理念：推演即生成

- **稀疏锚点 (Sparse Anchors)**: 仅定义 10-15 个关键剧情里程碑，而非 50-100 个预设场景
- **角色代理 (Character Agents)**: 基于 BDI (Belief-Desire-Intention) 模型的自主决策角色
- **世界裁决 (World Master)**: DM 引擎负责冲突仲裁、收敛控制、动态补路
- **推演生成 (Simulation-Driven)**: 多角色互动推演 → 叙事日志 → 智能渲染 → 正文

### 1.3 解决的核心问题

1. **涌现性缺失**: 通过角色自主决策产生意外剧情，而非执行预设大纲
2. **角色扁平化**: BDI 模型赋予角色独立的信念、欲望、意图，行为由内驱力决定
3. **节奏失控**: 中观层 (Act/Chapter) + 节奏监控 (info_gain) 确保叙事张力
4. **锚点不可达**: 动态补路算法生成过渡章节或软化锚点条件

### 1.4 系统规模

| 类别 | 数量 |
|------|------|
| API 端点 | 54 个 (原 32 + 新增 22) |
| 节点类型 | 16 个 (原 10 + 新增 6) |
| 边类型 | 8 个 (原 4 + 新增 4) |
| 服务模块 | 9 个 (原 5 + 新增 4) |
| Pydantic 模型 | 50 个 (原 32 + 新增 18) |

---

## 二、技术栈与全局约束

### 2.1 技术栈锁定

| 组件 | 技术选型 | 版本要求 |
|------|----------|----------|
| 开发语言 | Python | 3.11+ |
| Web 框架 | FastAPI | >= 0.111.0 |
| 数据验证 | Pydantic | >= 2.7.0 |
| 图数据库 | Memgraph | 最新稳定版 |
| 图数据库 ORM | GQLAlchemy | >= 1.4.0 |
| 图数据库驱动 | neo4j | >= 5.0.0, < 6.0.0 |
| HTTP 客户端 | httpx | >= 0.27.0 |
| ASGI 服务器 | uvicorn | >= 0.30.0 |
| 结构化输出 | instructor | >= 1.3.3 |

### 2.2 全局约束

**No-Go**:
- 禁止引入新 LLM SDK (必须通过 ToponeGateway)
- 禁止引入 langchain/llamaindex
- 禁止破坏现有 32 个 API 端点的兼容性

**Whitelist**: 仅允许 pyproject.toml 现有依赖 + asyncio/typing/enum/uuid/datetime (标准库)

### 2.3 LLM 服务配置

| 配置项 | 环境变量 | 默认值 |
|--------|----------|--------|
| API 密钥 | `TOPONE_API_KEY` | (必填) |
| 基础 URL | `TOPONE_BASE_URL` | `https://api.toponeapi.top` |
| 默认模型 | `TOPONE_DEFAULT_MODEL` | `gemini-3-pro-preview-11-2025` |
| 快速模型 | `TOPONE_SECONDARY_MODEL` | `gemini-3-flash-preview` |
| 超时时间 | `TOPONE_TIMEOUT_SECONDS` | 30 |

**LLM 角色分工**:
- **ARCHITECT**: 宏观规划，执行雪花法、锚点生成、幕章结构
- **REASONING**: 逻辑检察官，检测逻辑漏洞，收敛检查
- **CREATIVE**: 文学渲染，智能渲染管线
- **FLASH**: 快速处理，角色决策，状态提取

### 2.4 数据库配置

| 配置项 | 环境变量 | 默认值 |
|--------|----------|--------|
| 主机 | `MEMGRAPH_HOST` | (必填) |
| 端口 | `MEMGRAPH_PORT` | (必填) |
| 连接池最小 | `MEMGRAPH_POOL_MIN` | 10 |
| 连接池最大 | `MEMGRAPH_POOL_MAX` | 100 |
| 获取超时 | `MEMGRAPH_POOL_ACQUIRE_TIMEOUT` | 30.0 |
| 空闲超时 | `MEMGRAPH_POOL_IDLE_TIMEOUT` | 300.0 |

---

## 三、项目拓扑

### 3.1 目录结构

```
project/backend/
├── app/
│   ├── main.py                    # FastAPI 应用入口，54 个 API 端点
│   ├── models.py                  # Pydantic 数据模型 (50 个)
│   ├── config.py                  # 配置管理
│   ├── ports.py                   # 存储接口定义
│   ├── storage/
│   │   ├── memgraph_storage.py    # 核心存储实现
│   │   ├── schema.py              # GQLAlchemy ORM 模型 (16 个节点/边)
│   │   ├── temporal_edge.py       # 时序边管理
│   │   └── snapshot.py            # 快照机制
│   ├── services/
│   │   ├── world_state_service.py # 世界状态服务
│   │   ├── entity_resolver.py     # 实体消解
│   │   ├── impact_analyzer.py     # 影响分析
│   │   ├── dependency_matrix.py   # 依赖矩阵
│   │   ├── llm_engine.py          # LLM 引擎
│   │   ├── character_agent.py     # [New] BDI 决策引擎
│   │   ├── world_master.py        # [New] DM 裁决引擎 + 动态补路
│   │   ├── simulation_engine.py   # [New] 推演引擎
│   │   └── smart_renderer.py      # [New] 智能渲染管线
│   ├── llm/
│   │   ├── topone_client.py       # TopOne 客户端
│   │   ├── topone_gateway.py      # TopOne 网关
│   │   └── prompts/
│   │       ├── character_agent.py # [New] 角色 Prompt
│   │       ├── world_master.py    # [New] DM Prompt
│   │       └── renderer.py        # [New] 渲染 Prompt
│   └── utils/
│       └── graph_algorithms.py    # 图算法工具
├── tests/
│   ├── unit/                      # 单元测试
│   ├── integration/               # 集成测试
│   └── performance/               # 性能测试
├── docker-compose.memgraph.yml    # Docker 配置
└── pyproject.toml                 # 项目依赖
```

### 3.2 核心服务模块

| 模块 | 职责 |
|------|------|
| `character_agent.py` | BDI 决策引擎：感知 → 审议 → 行动，角色自主决策 |
| `world_master.py` | DM 裁决引擎：冲突仲裁、收敛检查、动态补路、节奏监控 |
| `simulation_engine.py` | 推演引擎：多角色回合制推演，场景生成 |
| `smart_renderer.py` | 智能渲染：推演日志降噪、感官注入、风格渲染 |
| `llm_engine.py` | LLM 引擎：雪花流程、锚点生成、幕章结构 |
| `world_state_service.py` | 世界状态：快照+增量混合查询 |
| `entity_resolver.py` | 实体消解：代词解析，Gemini Flash 集成 |
| `impact_analyzer.py` | 影响分析：受影响场景识别 |
| `dependency_matrix.py` | 依赖矩阵：影响查询优化 |

---

## 四、全局数据契约

### 4.1 三层图架构

系统图谱分为三个互联的子图：

**结构子图 (Structure Subgraph)** - 管理写作过程的版本控制
- 节点: `Root`, `Branch`, `BranchHead`, `Commit`, `SceneOrigin`, `SceneVersion`
- 节点: `Act`, `Chapter` (中观层)
- 边: `HEAD`, `PARENT`, `INCLUDES`, `OF_ORIGIN`, `CONTAINS_CHAPTER`, `CONTAINS_SCENE`

**叙事子图 (Narrative Subgraph)** - 管理故事世界观的动态演变
- 节点: `Entity`, `WorldSnapshot`, `StoryAnchor`, `Subplot`
- 边: `TemporalRelation`, `DEPENDS_ON`

**代理子图 (Agent Subgraph)** - 管理角色代理状态与推演日志
- 节点: `CharacterAgentState`, `SimulationLog`
- 边: `AGENT_OF`

### 4.2 节点类型定义 (16 个)

#### 4.2.1 结构子图节点 (8 个)

**Root (故事根节点)**
```python
class Root:
    id: str              # 唯一标识 (索引)
    logline: str         # 一句话核心
    theme: str           # 核心主旨
    ending: str          # 结局
    created_at: datetime # 创建时间
```

**Branch (分支节点)**
```python
class Branch:
    id: str                    # 格式: root_id:branch_id (索引)
    root_id: str               # 所属根节点 (索引)
    branch_id: str             # 分支标识 (索引)
    parent_branch_id: str      # 父分支
    fork_scene_origin_id: str  # 分叉点场景
    fork_commit_id: str        # 分叉点提交
```

**BranchHead (分支头指针)**
```python
class BranchHead:
    id: str             # 格式: root_id:branch_id:head (索引)
    root_id: str        # 所属根节点
    branch_id: str      # 分支标识
    head_commit_id: str # 当前提交
    version: int        # 乐观锁版本号 (并发控制)
```

**Commit (提交节点)**
```python
class Commit:
    id: str              # 唯一标识 (索引)
    parent_id: str       # 父提交
    message: str         # 提交信息
    created_at: datetime # 创建时间
    root_id: str         # 所属根节点 (索引)
    branch_id: str       # 所属分支
```

**Act (幕节点)**
```python
class Act:
    id: str           # 格式: {root_id}:act:{seq} (索引)
    root_id: str      # 所属根节点 (索引)
    sequence: int     # 幕序号
    title: str        # 幕标题
    purpose: str      # 幕目的
    tone: str         # 基调: "calm"|"tense"|"climax"|"resolution"
```

**Chapter (章节点)**
```python
class Chapter:
    id: str                      # 格式: {act_id}:ch:{seq} (索引)
    act_id: str                  # 所属幕 (索引)
    sequence: int                # 章序号
    title: str                   # 章标题
    focus: str                   # 章焦点
    pov_character_id: str|None   # 视点人物
```

**SceneOrigin (场景身份节点)**
```python
class SceneOrigin:
    id: str                # 唯一标识 (索引)
    root_id: str           # 所属根节点
    title: str             # 场景标题 (不可变)
    initial_commit_id: str # 初始提交
    sequence_index: int    # 序号 (关键索引)
    parent_act_id: str     # 所属幕
    chapter_id: str|None   # 所属章
    is_skeleton: bool      # 是否为骨架场景 (默认 false)
```

**SceneVersion (场景版本节点)**
```python
class SceneVersion:
    id: str                     # 唯一标识 (索引)
    scene_origin_id: str        # 关联场景原点 (索引)
    commit_id: str              # 关联提交 (索引)
    pov_character_id: str       # 视点人物
    status: str                 # 状态
    expected_outcome: str       # 大纲计划结果
    conflict_type: str          # 冲突类型
    actual_outcome: str         # 实际结果
    summary: str                # 摘要
    rendered_content: str       # 渲染内容
    logic_exception: bool       # 逻辑例外标记
    logic_exception_reason: str # 例外原因
    dirty: bool                 # 脏标记
    simulation_log_id: str|None # 关联推演日志
    is_simulated: bool          # 是否由推演生成 (默认 false)
```

#### 4.2.2 叙事子图节点 (4 个)

**Entity (实体节点)**
```python
class Entity:
    id: str                        # 唯一标识 (索引)
    root_id: str                   # 所属根节点
    branch_id: str                 # 所属分支 (索引)
    entity_type: str               # 类型: Character, Location, Item
    name: str                      # 名称
    tags: List[str]                # 标签
    semantic_states: Dict[str,str] # 语义状态快照
    arc_status: str                # 弧线状态
    has_agent: bool                # 是否有代理 (默认 false)
    agent_state_id: str|None       # 关联代理状态
```

**WorldSnapshot (世界状态快照)**
```python
class WorldSnapshot:
    id: str                  # 唯一标识 (索引)
    scene_version_id: str    # 关联场景版本 (索引)
    branch_id: str           # 分支标识
    scene_seq: int           # 场景序号 (索引)
    entity_states: Dict      # JSON 序列化的完整世界状态
    relations: List          # 关系列表
```

**StoryAnchor (故事锚点)**
```python
class StoryAnchor:
    id: str                    # 格式: {root_id}:anchor:{seq} (索引)
    root_id: str               # 所属根节点 (索引)
    branch_id: str             # 所属分支 (索引)
    sequence: int              # 锚点序号
    anchor_type: str           # 类型: "inciting_incident"|"midpoint"|"climax"|"resolution"|...
    description: str           # 锚点描述
    constraint_type: str       # 约束类型: "hard"|"soft"|"flexible"
    required_conditions: str   # JSON: 达成条件
    deadline_scene: int|None   # 截止场景序号
    achieved: bool             # 是否已达成 (默认 false)
```

**Subplot (支线)**
```python
class Subplot:
    id: str               # 唯一标识 (索引)
    root_id: str          # 所属根节点 (索引)
    branch_id: str        # 所属分支 (索引)
    title: str            # 支线标题
    subplot_type: str     # 类型: "romance"|"mystery"|"rivalry"|...
    protagonist_id: str   # 主角实体 ID
    central_conflict: str # 核心冲突
    status: str           # 状态: "dormant"|"active"|"resolved" (默认 "dormant")
```

#### 4.2.3 代理子图节点 (2 个)

**CharacterAgentState (角色代理状态)**
```python
class CharacterAgentState:
    id: str                  # 格式: agent:{char_id} (索引)
    character_id: str        # 关联角色实体 (索引)
    branch_id: str           # 所属分支 (索引)
    beliefs: str             # JSON: 信念 (对世界的认知)
    desires: str             # JSON: 欲望列表
    intentions: str          # JSON: 意图列表
    memory: str              # JSON: 记忆列表
    private_knowledge: str   # JSON: 私有知识 (其他角色不知道的)
    last_updated_scene: int  # 最后更新场景序号
    version: int             # 版本号 (默认 1)
```

**SimulationLog (推演日志)**
```python
class SimulationLog:
    id: str                  # 格式: sim:{scene_id}:round:{n} (索引)
    scene_version_id: str    # 关联场景版本 (索引)
    round_number: int        # 回合序号
    agent_actions: str       # JSON: 角色行动列表
    dm_arbitration: str      # JSON: DM 裁决结果
    narrative_events: str    # JSON: 叙事事件列表
    sensory_seeds: str       # JSON: 感官细节种子
    convergence_score: float # 收敛分数 (0-1)
    drama_score: float       # 戏剧分数 (0-1)
    info_gain: float         # 信息增量 (0-1)
    stagnation_count: int    # 连续停滞回合数 (默认 0)
```

### 4.3 边类型定义 (8 个)

#### 4.3.1 结构边 (6 个)

```python
class HEAD(Relationship): pass           # BranchHead -> Commit
class PARENT(Relationship): pass         # Commit -> Commit
class INCLUDES(Relationship): pass       # Commit -> SceneVersion
class OF_ORIGIN(Relationship): pass      # SceneVersion -> SceneOrigin
class CONTAINS_CHAPTER(Relationship): pass  # Act -> Chapter
class CONTAINS_SCENE(Relationship): pass    # Chapter -> SceneOrigin
```

#### 4.3.2 叙事边 (1 个)

**TemporalRelation (时序关系边)**
```python
class TemporalRelation:
    relation_type: str       # 关系类型: HATES, LOVES, AT, HAS 等
    tension: int             # 叙事张力值 (0-100)
    start_scene_seq: int     # 生效场景序号 (索引)
    end_scene_seq: int|None  # 失效场景序号, NULL=当前有效 (索引)
    branch_id: str           # 分支标识 (索引)
    created_at: datetime     # 创建时间
    invalidated_at: datetime|None # 失效时间
```

#### 4.3.3 代理边 (1 个)

```python
class AGENT_OF(Relationship): pass       # CharacterAgentState -> Entity
class DEPENDS_ON(Relationship): pass     # StoryAnchor -> StoryAnchor
```

### 4.4 索引策略 (22 个索引)

**结构子图索引**:
- `Root(id)`
- `Branch(id)`, `Branch(root_id, branch_id)`
- `BranchHead(id)`, `BranchHead(root_id, branch_id)`
- `Commit(id)`, `Commit(root_id)`
- `Act(id)`, `Act(root_id)`
- `Chapter(id)`, `Chapter(act_id)`
- `SceneOrigin(id)`, `SceneOrigin(root_id, sequence_index)`
- `SceneVersion(id)`, `SceneVersion(scene_origin_id)`, `SceneVersion(commit_id)`

**叙事子图索引**:
- `Entity(id)`, `Entity(branch_id)`, `Entity(root_id, branch_id)`
- `WorldSnapshot(id)`, `WorldSnapshot(scene_version_id)`, `WorldSnapshot(branch_id, scene_seq)`
- `StoryAnchor(id)`, `StoryAnchor(root_id, branch_id)`
- `Subplot(id)`, `Subplot(root_id, branch_id)`

**代理子图索引**:
- `CharacterAgentState(id)`, `CharacterAgentState(character_id)`, `CharacterAgentState(branch_id)`
- `SimulationLog(id)`, `SimulationLog(scene_version_id)`

**时序边索引**:
- `TemporalRelation(branch_id, start_scene_seq)`
- `TemporalRelation(branch_id, end_scene_seq)`

### 4.5 核心 Pydantic 模型 (50 个)

#### 4.5.1 BDI 模型

```python
class Desire(BaseModel):
    id: str
    type: Literal["short_term", "long_term", "reactive"]
    description: str
    priority: int = Field(ge=1, le=10)
    satisfaction_condition: str
    created_at_scene: int
    expires_at_scene: int|None = None

class Intention(BaseModel):
    id: str
    desire_id: str
    action_type: Literal["attack", "flee", "negotiate", "investigate", "wait", "other"]
    target: str
    expected_outcome: str
    risk_assessment: float = Field(ge=0, le=1)

class AgentAction(BaseModel):
    agent_id: str
    internal_thought: str
    action_type: str
    action_target: str
    dialogue: str|None = None
    action_description: str
```

#### 4.5.2 DM 裁决模型

```python
class ActionResult(BaseModel):
    action_id: str
    agent_id: str
    success: Literal["success", "partial", "failure"]
    reason: str
    actual_outcome: str

class DMArbitration(BaseModel):
    round_id: str
    action_results: List[ActionResult]
    conflicts_resolved: List[Dict] = []
    environment_changes: List[Dict] = []

class ConvergenceCheck(BaseModel):
    next_anchor_id: str
    distance: float = Field(ge=0, le=1)  # 0=达成, 1=偏离
    convergence_needed: bool
    suggested_action: str|None = None
```

#### 4.5.3 推演模型

```python
class SimulationRoundResult(BaseModel):
    round_id: str
    agent_actions: List[AgentAction]
    dm_arbitration: DMArbitration
    narrative_events: List[Dict]
    sensory_seeds: List[Dict]
    convergence_score: float
    drama_score: float
    info_gain: float
    stagnation_count: int

class ReplanRequest(BaseModel):
    current_scene_id: str
    target_anchor_id: str
    world_state_snapshot: Dict
    failed_conditions: List[str]

class ReplanResult(BaseModel):
    success: bool
    new_chapters: List[Dict]
    modified_anchor: Dict|None
    reason: str
```

#### 4.5.4 原有模型 (保持兼容)

**雪花流程模型**: `IdeaPayload`, `LoglinePayload`, `ScenePayload`, `Step4Result`

**分支管理模型**: `BranchView`, `BranchPayload`, `ForkFromCommitPayload`, `ForkFromScenePayload`, `ResetBranchPayload`

**实体管理模型**: `EntityView`, `EntityRelationView`, `CreateEntityPayload`, `UpsertRelationPayload`

**场景管理模型**: `SceneView`, `SceneContextView`, `SceneCompletePayload`, `SceneCompletionOrchestratePayload`, `SceneCompletionResult`, `SceneRenderResult`, `CreateSceneOriginPayload`, `CreateSceneOriginResult`, `DeleteSceneOriginPayload`, `SceneReorderPayload`, `SceneReorderResult`

**提交管理模型**: `CommitScenePayload`, `CommitResult`, `GcPayload`, `GcResult`

**视图模型**: `RootGraphView`, `StructureTreeView`, `StructureTreeActView`

---

## 五、API 端点定义 (54 个)

### 5.1 雪花流程 API (6 个)

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/snowflake/step1` | 生成 10 个 logline 选项 |
| POST | `/api/v1/snowflake/step2` | 生成故事结构 (Root) |
| POST | `/api/v1/snowflake/step3` | 生成角色小传 |
| POST | `/api/v1/snowflake/step4` | 生成场景骨架 |
| POST | `/api/v1/snowflake/step5a` | 生成幕结构 (3-5 Acts) |
| POST | `/api/v1/snowflake/step5b` | 生成章结构 (每幕 3-7 Chapters) |

### 5.2 锚点管理 API (4 个)

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/roots/{root_id}/anchors` | 生成稀疏锚点 (10-15 个) |
| GET | `/api/v1/roots/{root_id}/anchors` | 列出锚点 |
| PUT | `/api/v1/anchors/{id}` | 更新锚点 |
| POST | `/api/v1/anchors/{id}/check` | 检查锚点可达性 |

### 5.3 角色代理 API (4 个)

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/entities/{id}/agent/init` | 初始化角色代理 (BDI) |
| GET | `/api/v1/entities/{id}/agent/state` | 获取代理状态 |
| PUT | `/api/v1/entities/{id}/agent/desires` | 更新欲望列表 |
| POST | `/api/v1/entities/{id}/agent/decide` | 触发角色决策 |

### 5.4 DM 裁决 API (4 个)

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/dm/arbitrate` | 裁决角色行动 |
| POST | `/api/v1/dm/converge` | 检查收敛状态 |
| POST | `/api/v1/dm/intervene` | DM 主动干预 |
| POST | `/api/v1/dm/replan` | 动态补路 |

### 5.5 推演引擎 API (4 个)

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/simulation/round` | 单回合推演 |
| POST | `/api/v1/simulation/scene` | 完整场景推演 |
| GET | `/api/v1/simulation/logs/{scene_id}` | 获取推演日志 |
| POST | `/api/v1/render/scene` | 智能渲染 |

### 5.6 分支管理 API (9 个)

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/roots/{root_id}/branches` | 创建分支 |
| GET | `/api/v1/roots/{root_id}/branches` | 列出分支 |
| POST | `/api/v1/roots/{root_id}/branches/{branch_id}/switch` | 切换分支 |
| POST | `/api/v1/roots/{root_id}/branches/{branch_id}/merge` | 合并分支 |
| POST | `/api/v1/roots/{root_id}/branches/{branch_id}/revert` | 回滚分支 |
| POST | `/api/v1/roots/{root_id}/branches/fork_from_commit` | 从提交创建分支 |
| POST | `/api/v1/roots/{root_id}/branches/fork_from_scene` | 从场景创建分支 |
| POST | `/api/v1/roots/{root_id}/branches/{branch_id}/reset` | 重置分支 |
| GET | `/api/v1/roots/{root_id}/branches/{branch_id}/history` | 获取分支历史 |

### 5.7 场景管理 API (8 个)

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/roots/{root_id}/scene_origins` | 创建场景 |
| POST | `/api/v1/roots/{root_id}/scenes/{scene_id}/delete` | 删除场景 |
| POST | `/api/v1/scenes/{scene_id}/complete` | 完成场景 |
| POST | `/api/v1/scenes/{scene_id}/complete/orchestrated` | 编排完成场景 (含逻辑检查) |
| POST | `/api/v1/scenes/{scene_id}/render` | 渲染场景 |
| GET | `/api/v1/scenes/{scene_id}/context` | 获取场景上下文 |
| GET | `/api/v1/scenes/{scene_id}/diff` | 比较场景版本 |
| POST | `/api/v1/scenes/{scene_id}/dirty` | 标记场景为脏 |

### 5.8 中观层 API (2 个)

| 方法 | 路径 | 功能 |
|------|------|------|
| GET | `/api/v1/roots/{root_id}/acts` | 获取幕列表 |
| GET | `/api/v1/acts/{act_id}/chapters` | 获取章列表 |

### 5.9 实体管理 API (3 个)

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/roots/{root_id}/entities` | 创建实体 |
| GET | `/api/v1/roots/{root_id}/entities` | 列出实体 |
| POST | `/api/v1/roots/{root_id}/relations` | 创建/更新关系 |

### 5.10 查询 API (2 个)

| 方法 | 路径 | 功能 |
|------|------|------|
| GET | `/api/v1/roots/{root_id}` | 获取根节点快照 |
| GET | `/api/v1/roots/{root_id}/dirty_scenes` | 列出脏场景 |

### 5.11 提交 API (2 个)

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/roots/{root_id}/branches/{branch_id}/commit` | 提交场景 |
| POST | `/api/v1/commits/gc` | 垃圾回收孤立提交 |

### 5.12 LLM 和逻辑检查 API (4 个)

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/llm/topone/generate` | 调用 TopOne Gemini |
| POST | `/api/v1/logic/check` | 逻辑检查 |
| POST | `/api/v1/state/extract` | 状态提取 |
| POST | `/api/v1/state/commit` | 提交状态 |

---

## 六、核心算法实现

### 6.1 BDI 决策引擎

**文件**: `app/services/character_agent.py`

**功能**: 基于 Belief-Desire-Intention 模型的角色自主决策。

**决策流程**:
```
输入: agent_id, scene_context

步骤:
1. perceive(agent_id, scene_context):
   - 更新 beliefs: world.location, others.{id}.state
   - 从场景上下文提取可观察信息
   - 返回 updated_beliefs

2. deliberate(agent_id):
   - 过滤有效欲望 (未过期)
   - 按 priority DESC 排序
   - 对 top 3 欲望: LLM 生成 intention
   - 返回 intentions 列表

3. act(agent_id, scene_context):
   - 获取 intentions
   - IF empty THEN return wait_action
   - 检查前置条件
   - LLM 生成具体行动
   - 返回 AgentAction

输出: AgentAction {agent_id, internal_thought, action_type, action_target, dialogue, action_description}
```

### 6.2 DM 裁决引擎

**文件**: `app/services/world_master.py`

**功能**: 冲突仲裁、收敛控制、动态补路、节奏监控。

**裁决流程**:
```
输入: round_id, actions[], world_state, rules

步骤:
1. detect_conflicts(actions):
   - IF both attack each other THEN conflict
   - IF same target same action THEN conflict
   - 返回 conflict_pairs[]

2. resolve_conflicts(conflict_pairs):
   - 根据能力值、位置优势等裁决胜负
   - 返回 resolution[]

3. check_action_validity(action, world_state, rules):
   - FOR rule in rules: IF violates THEN failure
   - IF power_level mismatch THEN partial
   - ELSE success
   - 返回 ActionResult

4. inject_sensory_seeds(scene_context):
   - 随机注入感官细节种子
   - 类型: weather, ambient_sound, character_gesture, object_detail
   - 返回 sensory_seeds[]

输出: DMArbitration {round_id, action_results[], conflicts_resolved[], environment_changes[]}
```

**节奏监控算法**:
```
输入: rounds[] (最近推演回合)

步骤:
1. 计算最近 3 轮的 info_gain 平均值
   avg_info_gain = mean([r.info_gain for r in rounds[-3:]])

2. IF avg_info_gain < 0.2:
   - 触发突发事件打破僵局
   - 返回 PacingAction(type="inject_incident")

3. IF is_deescalating(rounds[-3:]):
   - 冲突连续下降，强制升级
   - 返回 PacingAction(type="force_escalation")

4. ELSE:
   - 返回 PacingAction(type="continue")
```

### 6.3 动态补路算法

**文件**: `app/services/world_master.py`

**功能**: 当推演偏离锚点时，生成过渡章节或调整锚点。

**补路流程**:
```
输入: current_scene, target_anchor, world_state

步骤:
1. analyze_gap(world_state, target_anchor.required_conditions):
   - 评估当前状态与目标锚点的差距
   - 返回 gap {severity: 0-1, recoverable: bool, missing_conditions[]}

2. IF gap.severity < 0.7:
   - 生成过渡章节
   new_chapters = generate_bridge_chapters(
       from_state=world_state,
       to_conditions=target_anchor.required_conditions,
       max_chapters=3
   )
   - 返回 ReplanResult(success=true, new_chapters)

3. IF target_anchor.constraint_type == "soft":
   - 软化锚点条件
   modified = soften_anchor(target_anchor, world_state)
   - 返回 ReplanResult(success=true, modified_anchor=modified)

4. IF target_anchor.constraint_type == "flexible":
   - 替换为等效锚点
   replacement = generate_equivalent_anchor(target_anchor, world_state)
   - 返回 ReplanResult(success=true, modified_anchor=replacement)

5. ELSE:
   - 标记为不可恢复
   - 返回 ReplanResult(success=false, reason="hard_anchor_unreachable")
```

### 6.4 智能渲染管线

**文件**: `app/services/smart_renderer.py`

**功能**: 将推演日志转化为文学正文，解决"推演→正文"的风格断层。

**渲染流程**:
```
输入: rounds[], scene

步骤:
1. extract_narrative_beats(rounds):
   - 过滤 info_gain < 0.1 的回合
   - 移除 action_result.success == "failure" 且无戏剧价值的动作
   - 合并连续的 "wait" 动作
   - 保留所有对话和关键冲突
   - 返回 clean_beats[]

2. collect_sensory_seeds(rounds):
   - 收集所有感官细节种子
   - 按类型分组: weather, gesture, ambient, object
   - 返回 sensory_details{}

3. get_style_context(scene_id):
   - 检索前文伏笔
   - 获取角色语气 (voice_dna)
   - 确定场景基调
   - 返回 style_context{}

4. generate_prose(beats, sensory, style, pov):
   - LLM 渲染正文
   - 融入感官细节
   - 保持角色语气一致
   - 返回 content

5. check_continuity_errors(content, scene):
   - 检查角色位置、物品状态、时间线、已知信息
   - IF errors THEN fix_continuity(content)
   - 返回 final_content
```

### 6.5 时序边管理算法

**文件**: `app/storage/temporal_edge.py`

**功能**: 追踪实体状态的完整变化历史，支持时间旅行查询。

**创建/更新关系算法**:
```
输入: from_entity_id, to_entity_id, relation_type, tension, scene_seq, branch_id

步骤:
1. 查找所有活跃的同类型关系:
   WHERE start_scene_seq <= current_seq AND end_scene_seq IS NULL
2. 将这些关系的 end_scene_seq 设置为 current_seq (失效旧边)
3. 创建新关系:
   start_scene_seq = current_seq
   end_scene_seq = NULL
4. 使用事务保证原子性
```

**时间旅行查询算法**:
```
输入: from_entity_id, branch_id, target_scene_seq

查询条件:
WHERE r.branch_id = $branch_id
  AND r.start_scene_seq <= $target_scene_seq
  AND (r.end_scene_seq IS NULL OR r.end_scene_seq > $target_scene_seq)

返回: 该时间点的所有活跃关系
```

### 6.6 快照机制算法

**文件**: `app/storage/snapshot.py`

**功能**: 优化历史状态查询性能，避免遍历所有时序边。

**快照创建规则**:
```python
def should_create_snapshot(scene_seq: int) -> bool:
    return scene_seq > 0 and scene_seq % 10 == 0
```

**世界状态查询优化算法**:
```
输入: branch_id, target_scene_seq

步骤:
1. 计算最近快照点: snapshot_seq = (target_seq // 10) * 10
2. 查询快照节点获取基础状态
3. 如果 snapshot_seq < target_seq:
   - 查询增量变更: start_seq > snapshot_seq AND start_seq <= target_seq
   - 应用增量变更到基础状态
4. 返回完整世界状态

复杂度分析:
- 最坏情况: O(E×10) - 从快照回放 10 个场景
- 最好情况: O(1) - 直接命中快照
- 平均情况: O(E×5)
```

### 6.7 收敛检查算法

**文件**: `app/services/world_master.py`

**功能**: 评估当前世界状态与下一个锚点的距离。

**收敛检查流程**:
```
输入: world_state, next_anchor

步骤:
1. LLM 评估距离 (0-1):
   - 0 = 锚点已达成
   - 1 = 完全偏离

2. IF distance > 0.7 THEN convergence_needed = true

3. generate_convergence_action(distance, world_state):
   - distance < 0.5: npc_hint (NPC 暗示)
   - distance < 0.7: environment_pressure (环境压力)
   - distance < 0.9: deus_ex_machina (机械降神)
   - distance >= 0.9: trigger replan_route() (动态补路)

输出: ConvergenceCheck {next_anchor_id, distance, convergence_needed, suggested_action}
```

---

## 七、业务流程

### 7.1 雪花流程数据流 (Step 1-5)

```
用户想法
  ↓
Step 1: POST /api/v1/snowflake/step1
  → 生成 10 个 logline 选项
  ↓
用户选择 logline
  ↓
Step 2: POST /api/v1/snowflake/step2
  → 扩展成故事结构 (Root)
  ├─ logline
  ├─ three_disasters (3 个灾难)
  ├─ ending
  └─ theme
  ↓
Step 3: POST /api/v1/snowflake/step3
  → 生成角色小传
  ├─ name, ambition, conflict, epiphany, voice_dna
  └─ 验证角色与主线冲突
  ↓
Step 4: POST /api/v1/snowflake/step4
  → 生成场景骨架 (skeleton scenes)
  ↓
Step 5a: POST /api/v1/snowflake/step5a
  → 生成幕结构 (3-5 Acts)
  ├─ title, purpose, tone
  └─ 保存 Act 节点
  ↓
Step 5b: POST /api/v1/snowflake/step5b
  → 生成章结构 (每幕 3-7 Chapters)
  ├─ title, focus, pov_character_id
  └─ 保存 Chapter 节点，关联 Act
  ↓
Root + Characters + Acts + Chapters 持久化
```

### 7.2 锚点生成数据流

```
雪花流程完成后
  ↓
POST /api/v1/roots/{root_id}/anchors
  → 生成稀疏锚点 (10-15 个)
  ├─ 必须包含: inciting_incident, midpoint, climax, resolution
  ├─ 每个锚点: anchor_type, description, constraint_type, required_conditions
  └─ 保存 StoryAnchor 节点
  ↓
锚点依赖关系
  → 创建 DEPENDS_ON 边
  ↓
锚点系统就绪，等待推演
```

### 7.3 角色代理初始化数据流

```
角色实体创建后
  ↓
POST /api/v1/entities/{id}/agent/init
  → 初始化 BDI 代理
  ├─ 从角色小传提取初始 beliefs
  ├─ 从 ambition/conflict 生成初始 desires
  ├─ intentions = []
  ├─ memory = []
  └─ private_knowledge = []
  ↓
创建 CharacterAgentState 节点
  → 创建 AGENT_OF 边
  → 更新 Entity: has_agent=true
  ↓
角色代理就绪，可参与推演
```

### 7.4 场景推演数据流 (核心流程)

```
场景骨架 (SceneOrigin)
  ↓
POST /api/v1/simulation/scene
  → 启动场景推演
  ↓
FOR round in range(max_rounds):
  │
  ├─ 1. 角色决策 (并行)
  │   FOR agent in scene_agents:
  │     └─ agent.decide(scene_context) → AgentAction
  │
  ├─ 2. DM 裁决
  │   └─ world_master.arbitrate(actions) → DMArbitration
  │       ├─ 冲突检测与解决
  │       ├─ 行动有效性检查
  │       ├─ 环境变化生成
  │       └─ 感官种子注入
  │
  ├─ 3. 状态更新
  │   ├─ 更新 agent beliefs/memory
  │   ├─ 更新 world_state
  │   └─ 创建 TemporalRelation (时序边)
  │
  ├─ 4. 节奏监控
  │   └─ world_master.monitor_pacing(rounds)
  │       ├─ IF stagnation → inject_incident
  │       └─ IF deescalating → force_escalation
  │
  ├─ 5. 收敛检查
  │   └─ world_master.check_convergence(world_state, next_anchor)
  │       ├─ IF distance > 0.9 → trigger replan_route()
  │       └─ ELSE → apply convergence_action
  │
  └─ 6. 结束判断
      └─ IF should_end_scene(round) THEN break
  ↓
推演完成，生成 SimulationLog
  ↓
POST /api/v1/render/scene
  → 智能渲染
  ├─ 降噪: 过滤无效回合
  ├─ 感官注入: 融入 sensory_seeds
  ├─ 风格渲染: 保持角色语气
  └─ 一致性检查
  ↓
SceneVersion (is_simulated=true, rendered_content)
```

### 7.5 动态补路数据流

```
收敛检查发现 distance >= 0.9
  ↓
POST /api/v1/dm/replan
  → 动态补路
  ↓
analyze_gap(world_state, target_anchor)
  ├─ severity < 0.7 → 生成过渡章节
  │   └─ 插入 1-3 个 bridge chapters
  │
  ├─ constraint_type == "soft" → 软化锚点
  │   └─ 放宽 required_conditions
  │
  ├─ constraint_type == "flexible" → 替换锚点
  │   └─ 生成等效锚点
  │
  └─ constraint_type == "hard" → 标记不可恢复
      └─ 需人工介入
  ↓
ReplanResult {success, new_chapters, modified_anchor, reason}
```

### 7.6 锚点达成数据流

```
推演过程中
  ↓
check_anchor_conditions(world_state, anchor)
  → 检查锚点条件是否满足
  ↓
IF all conditions met:
  ├─ mark_anchor_achieved(anchor_id, scene_version_id)
  ├─ 创建 TRIGGERED_AT 边
  └─ 获取下一个未达成锚点
  ↓
继续推演直到所有锚点达成或故事结束
```

---

## 八、性能指标

### 8.1 推演性能目标

| 指标 | 目标值 | 说明 |
|------|--------|------|
| 单回合推演延迟 (P95) | < 2s | 含角色决策 + DM 裁决 |
| 单场景推演延迟 (P95) | < 10s | 含多回合推演 + 渲染 |
| 角色行为一致性 | > 85% | BDI 约束下的行为合理性 |
| 锚点达成率 | > 90% | 稀疏锚点最终达成比例 |
| 收束成功率 | > 95% | DM 干预后回归轨道比例 |
| 平均 info_gain/回合 | > 0.3 | 信息增量，避免水文 |
| 渲染后正文质量评分 | > 4.0/5.0 | 人工评估 |
| 动态补路成功率 | > 80% | 锚点不可达时的恢复率 |

### 8.2 查询性能目标

| 指标 | 目标值 | 说明 |
|------|--------|------|
| 简单查询延迟 (P95) | < 200ms | 单节点/单边查询 |
| 复杂查询延迟 (P95) | < 500ms | 时序范围/多跳遍历 |
| 快照直接命中 (P95) | < 100ms | 快照查询 |
| 写操作延迟 (P95) | < 300ms | 含事务提交 |

### 8.3 吞吐量与并发目标

| 指标 | 目标值 | 说明 |
|------|--------|------|
| 吞吐量 | > 50 QPS | 混合读写 |
| 并发用户数 | > 50 | 保守估计 |
| 内存占用 | < 20GB | 32GB 配置下 |
| 连接池获取时间 | < 10ms | 平均值 |
| 缓存命中率 | > 80% | 实体/关系缓存 |

### 8.4 LLM 调用性能目标

| 指标 | 目标值 | 说明 |
|------|--------|------|
| 角色决策延迟 (P95) | < 1s | 使用 Flash 模型 |
| DM 裁决延迟 (P95) | < 1.5s | 使用 Pro 模型 |
| 智能渲染延迟 (P95) | < 3s | 使用 Creative 模型 |
| 并行角色决策 | 支持 5+ | 同时处理多角色 |

### 8.5 可扩展性目标

| 指标 | 目标值 |
|------|--------|
| 支持故事数 | 1000+ |
| 支持场景数 | 10000+ |
| 支持实体数 | 1000+ |
| 支持角色代理数 | 50+/故事 |
| 支持锚点数 | 100+/故事 |
| 支持并发用户 | 100+ |

---

## 九、测试规范

### 9.1 测试分层

| 层级 | 目录 | 职责 |
|------|------|------|
| 单元测试 | `tests/unit/` | ORM 模型验证，BDI 逻辑，DM 算法 |
| 集成测试 | `tests/integration/` | GraphStorage + Memgraph, 推演流程 |
| 性能测试 | `tests/performance/` | 压测，基准测试 |

### 9.2 测试文件清单

**单元测试 (tests/unit/)**:
- `test_schema_act_chapter.py` - Act/Chapter 节点验证
- `test_schema_anchor.py` - StoryAnchor 节点验证
- `test_schema_agent.py` - CharacterAgentState 节点验证
- `test_schema_simulation.py` - SimulationLog 节点验证
- `test_models_bdi.py` - BDI 模型验证 (Desire, Intention, AgentAction)
- `test_models_dm.py` - DM 模型验证 (ActionResult, DMArbitration)
- `test_character_agent.py` - BDI 决策引擎单元测试
- `test_world_master.py` - DM 裁决引擎单元测试
- `test_route_replanner.py` - 动态补路算法测试
- `test_smart_renderer.py` - 智能渲染管线测试
- `test_prompts.py` - Prompt 模板验证

**集成测试 (tests/integration/)**:
- `test_act_chapter_storage.py` - 幕章存储 CRUD
- `test_anchor_storage.py` - 锚点存储与依赖
- `test_agent_storage.py` - 代理状态存储
- `test_simulation_flow.py` - 完整推演流程
- `test_pacing_control.py` - 节奏监控集成测试
- `test_snowflake_step5.py` - Step5a/5b 集成测试
- `test_anchor_api.py` - 锚点 API 测试
- `test_agent_api.py` - 代理 API 测试
- `test_dm_api.py` - DM API 测试
- `test_simulation_api.py` - 推演 API 测试

### 9.3 核心测试用例

**测试 1: BDI 决策流程**
```
Given: 角色代理 (beliefs: {enemy_nearby: true}, desires: [{type: "reactive", priority: 9, desc: "survive"}])
When: agent.decide(scene_context)
Then: 返回 AgentAction(action_type="flee" or "attack")
```

**测试 2: DM 冲突裁决**
```
Given: actions = [A attacks B, B attacks A]
When: world_master.arbitrate(actions)
Then: 返回 DMArbitration 包含 1 个 conflict_resolved
```

**测试 3: 节奏监控触发**
```
Given: rounds[-3:] 的 info_gain 均 < 0.1
When: world_master.monitor_pacing(rounds)
Then: 返回 PacingAction(type="inject_incident")
```

**测试 4: 动态补路 - 生成过渡章节**
```
Given: gap.severity = 0.5, target_anchor.constraint_type = "hard"
When: replan_route(current_scene, target_anchor, world_state)
Then: 返回 ReplanResult(success=true, new_chapters=[...])
```

**测试 5: 动态补路 - 软化锚点**
```
Given: gap.severity = 0.8, target_anchor.constraint_type = "soft"
When: replan_route(current_scene, target_anchor, world_state)
Then: 返回 ReplanResult(success=true, modified_anchor={...})
```

**测试 6: 智能渲染降噪**
```
Given: rounds 包含 3 个 info_gain < 0.1 的回合
When: smart_renderer.render(rounds, scene)
Then: 输出内容不包含这些回合的细节
```

**测试 7: 感官种子注入**
```
Given: rounds 包含 sensory_seeds = [{type: "weather", detail: "暴雨"}]
When: smart_renderer.render(rounds, scene)
Then: 输出内容包含天气描写
```

**测试 8: 锚点达成检测**
```
Given: anchor.required_conditions = ["hero_has_sword"]
       world_state.entities["hero"].has = ["sword"]
When: check_anchor_conditions(world_state, anchor)
Then: 返回 true, 触发 mark_anchor_achieved
```

### 9.4 测试覆盖率目标

| 模块 | 单元测试 | 集成测试 |
|------|----------|----------|
| CharacterAgentEngine | > 80% | > 70% |
| WorldMasterEngine | > 80% | > 70% |
| SimulationEngine | > 75% | > 80% |
| SmartRenderer | > 75% | > 70% |
| GraphStorage | > 80% | > 70% |
| API Endpoints | > 60% | > 75% |

### 9.5 测试执行命令

```bash
# 运行所有测试
pytest -q -rs

# 运行新增模块测试
pytest -q -k "agent or simulation or anchor or renderer"

# 运行集成测试
pytest -q tests/integration/

# 运行性能测试
pytest -q -k benchmark

# 运行覆盖率报告
pytest --cov=app --cov-report=html
```

---

## 十、部署配置

### 10.1 Docker 部署

```bash
# 启动 Memgraph
docker compose -f project/backend/docker-compose.memgraph.yml up -d

# 启动应用
uvicorn app.main:app --host 0.0.0.0 --port 8000
```

### 10.2 环境变量配置

```bash
# 必填配置
export MEMGRAPH_HOST=localhost
export MEMGRAPH_PORT=7687
export TOPONE_API_KEY=your_key

# 可选配置
export MEMGRAPH_POOL_MIN=10
export MEMGRAPH_POOL_MAX=100
export MEMGRAPH_POOL_ACQUIRE_TIMEOUT=30.0
export MEMGRAPH_POOL_IDLE_TIMEOUT=300.0
export TOPONE_TIMEOUT_SECONDS=30
```

### 10.3 连接池配置

| 参数 | 默认值 | 说明 |
|------|--------|------|
| min_size | 10 | 最小连接数 |
| max_size | 100 | 最大连接数 |
| acquire_timeout | 30s | 获取连接超时 |
| idle_timeout | 300s | 空闲连接超时 |

### 10.4 缓存配置

系统使用三层缓存架构:
- `_entity_cache`: 实体缓存 (root_id, branch_id) -> 实体列表
- `_character_cache`: 角色缓存 (root_id, branch_id) -> 角色列表
- `_agent_state_cache`: 代理状态缓存 (agent_id) -> AgentState

缓存使用线程锁保护，支持并发安全访问。

---

## 十一、错误处理

### 11.1 API 错误码

| 状态码 | 场景 | 示例 |
|--------|------|------|
| 400 | 输入验证失败 | Desire.priority 超出 1-10 范围 |
| 404 | 资源不存在 | 锚点/代理/场景不存在 |
| 409 | 冲突 | 代理已存在，锚点已达成 |
| 422 | 业务逻辑错误 | 硬锚点不可达 |
| 500 | 服务器错误 | 数据库连接失败 |

### 11.2 推演错误处理

| 错误类型 | 处理策略 |
|----------|----------|
| 角色决策超时 | 返回 wait_action，记录日志 |
| DM 裁决失败 | 重试一次，失败则跳过本回合 |
| 收敛检查失败 | 使用默认 distance=0.5 |
| 动态补路失败 | 标记锚点为 unreachable，通知用户 |
| 渲染失败 | 返回推演日志摘要作为降级内容 |

### 11.3 并发冲突处理

使用乐观锁机制:
1. BranchHead 节点包含 version 字段
2. CharacterAgentState 节点包含 version 字段
3. 更新前查询当前 version
4. 更新时检查 version 是否匹配
5. 不匹配则抛出 `ConcurrentModificationError`

---

## 十二、监控与告警

### 12.1 关键监控指标

- API 响应时间 (P50, P95, P99)
- 推演回合延迟
- 角色决策延迟
- DM 裁决延迟
- 智能渲染延迟
- 锚点达成率
- 收敛成功率
- 动态补路触发次数
- LLM API 调用次数和成功率
- 错误率

### 12.2 告警规则

| 指标 | Warning | Critical |
|------|---------|----------|
| 推演回合延迟 P99 | > 3s | > 5s |
| 角色决策失败率 | > 5% | > 15% |
| 锚点达成率 | < 85% | < 70% |
| 收敛成功率 | < 90% | < 80% |
| 内存占用 | > 25GB | > 30GB |
| 连接池使用率 | > 80% | > 95% |

### 12.3 日志级别

- **DEBUG**: 详细的推演过程，角色决策细节
- **INFO**: 重要事件 (场景推演开始/结束、锚点达成)
- **WARNING**: 潜在问题 (节奏停滞、收敛困难)
- **ERROR**: 错误情况 (推演失败、补路失败)

---

## 附录 A: BDI 角色决策 Prompt 设计

```text
你是角色 {character_name}，正在场景 {scene_title} 中行动。

## 你的身份
- 名字: {name}
- 野心: {ambition}
- 内心冲突: {conflict}
- 语气特征: {voice_dna}

## 你当前的认知 (Beliefs)
{beliefs_json}

## 你的欲望 (Desires)
{desires_json}

## 当前场景
{scene_context}

## 任务
基于你的性格、认知和欲望，决定你在这个场景中的行动。

输出格式 (JSON):
{
  "internal_thought": "你的内心独白，不超过50字",
  "action_type": "attack|flee|negotiate|investigate|wait|other",
  "action_target": "行动目标",
  "dialogue": "你说的话（可选）",
  "action_description": "你的具体行动描述"
}

注意：
1. 行动必须符合你的性格和当前认知
2. 不要做出你不知道的信息相关的行动
3. 优先满足高优先级的欲望
```

---

## 附录 B: DM 裁决 Prompt 设计

```text
你是这个故事世界的裁决者 (Dungeon Master)。你的任务是裁决角色行动的结果。

## 世界规则
{world_rules}

## 当前世界状态
{world_state_json}

## 本回合角色行动
{actions_json}

## 任务
1. 检测行动之间的冲突
2. 裁决每个行动的成功/失败/部分成功
3. 生成环境变化
4. 注入 1-2 个感官细节种子

输出格式 (JSON):
{
  "action_results": [
    {"action_id": "...", "agent_id": "...", "success": "success|partial|failure", "reason": "...", "actual_outcome": "..."}
  ],
  "conflicts_resolved": [
    {"agents": ["a1", "a2"], "resolution": "..."}
  ],
  "environment_changes": [
    {"type": "...", "description": "..."}
  ],
  "sensory_seeds": [
    {"type": "weather|gesture|ambient|object", "detail": "...", "char_id": "...（可选）"}
  ]
}

裁决原则：
1. 能力值高的角色更容易成功
2. 位置优势影响结果
3. 意外因素可以改变结果（但要合理）
4. 感官细节要与场景氛围一致
```

---

## 附录 C: 智能渲染 Prompt 设计

```text
你是一位文学渲染专家。将推演日志转化为小说正文。

## 场景信息
- 标题: {scene_title}
- 视点人物: {pov_character}
- 基调: {tone}

## 推演日志 (已降噪)
{narrative_beats_json}

## 感官细节种子
{sensory_seeds_json}

## 风格上下文
- 前文伏笔: {foreshadowing}
- 角色语气: {voice_dna}

## 任务
将推演日志渲染为文学正文，要求：
1. 使用第三人称限制视角（{pov_character} 的视角）
2. 融入感官细节种子，但不要生硬
3. 保持角色语气一致
4. 对话要符合角色性格
5. 不要添加推演日志中没有的情节

输出：纯文本小说正文，1000-2000字
```

---

## 附录 D: 收敛检查 Prompt 设计

```text
你是故事收敛评估专家。评估当前世界状态与目标锚点的距离。

## 目标锚点
- 类型: {anchor_type}
- 描述: {anchor_description}
- 达成条件: {required_conditions}

## 当前世界状态
{world_state_json}

## 任务
评估当前状态距离锚点达成还有多远。

输出格式 (JSON):
{
  "distance": 0.0-1.0,  // 0=已达成, 1=完全偏离
  "analysis": "分析说明",
  "missing_conditions": ["缺失的条件1", "缺失的条件2"],
  "suggested_action": "建议的收敛行动（如果需要）"
}

评估标准：
- 0.0-0.3: 接近达成，自然发展即可
- 0.3-0.5: 需要轻微引导 (NPC 暗示)
- 0.5-0.7: 需要中度干预 (环境压力)
- 0.7-0.9: 需要强力干预 (突发事件)
- 0.9-1.0: 严重偏离，需要动态补路
```

---

## 附录 E: 相关文档索引

| 文档 | 路径 | 说明 |
|------|------|------|
| 实施协议 | `doc/multi_agent_narrative_system_plan.md` | 多智能体系统实施步骤 |
| API 文档 | `doc/API.md` | REST API 接口说明 |
| 部署文档 | `doc/DEPLOYMENT.md` | 部署步骤与配置 |

---

**文档维护说明**: 本文档描述 AI Novel V4.0 多智能体叙事系统的完整技术规格。如有架构变更，请同步更新本文档与实施协议。
